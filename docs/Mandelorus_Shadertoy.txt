
// ========================================================================
// THE MANDELORUS (HYPERTORUS) - SHADERTOY IMPLEMENTATION
// Based on the "Reconstruction" method for topological fidelity.
//
// AUTHOR: Guy Zack
// LICENSE: GPL-3.0
// DATE: 2024
//
// INSTRUCTIONS:
// 1. Go to https://www.shadertoy.com/new
// 2. Paste this entire text into the code editor.
// 3. Hit Compile (Alt+Enter).
// 4. Click and Drag on the viewport to rotate the camera.
// ========================================================================

// --- PARAMETERS (User Requested) ---
const int MAX_ITER = 128;      // Raymarching steps
const float EPSILON = 0.0005;  // Hit threshold
const float MAX_DIST = 20.0;   // Fog distance

// Fractal Settings
const int Iterations = 40;
const float RingRadius = 0.1;
const float Twist = 0.0;
const float Power = 3.0;
const float RingPhase = 0.0;
const float CrossPhase = -1.57079; // -0.5 * PI
const float VertScale = 1.0;       // Scale 1.0 (Input "0" offset)
const float Bailout = 4.0;

// Coloring Settings (GMT Values)
const float ColorMin = 0.045;
const float ColorMax = 0.28;
const float ColorRepeats = 4.0;

// --- PALETTE ---
// Custom Spectral-Divergent Gradient provided by user
vec3 paletteCustom(float t) {
    // Clamp is handled by the mapping logic before calling this, 
    // but we keep it safe here for the gradient stops.
    t = clamp(t, 0.0, 1.0);
    
    vec3 c0 = vec3(0.620, 0.004, 0.259); // #9e0142
    vec3 c1 = vec3(0.835, 0.243, 0.310); // #d53e4f
    vec3 c2 = vec3(0.957, 0.427, 0.263); // #f46d43
    vec3 c3 = vec3(0.992, 0.682, 0.380); // #fdae61
    vec3 c4 = vec3(0.996, 0.878, 0.545); // #fee08b
    vec3 c5 = vec3(0.000, 0.000, 0.000); // #000000 (Hard Stop)
    vec3 c6 = vec3(0.459, 0.180, 0.102); // #752E1A
    vec3 c7 = vec3(1.000, 0.769, 0.302); // #FFC44D
    vec3 c8 = vec3(1.000, 1.000, 1.000); // #FFFFFF
    vec3 c9 = vec3(0.008, 0.016, 0.055); // #02040E
    vec3 c10 = vec3(0.196, 0.533, 0.741); // #3288bd
    vec3 c11 = vec3(0.369, 0.310, 0.635); // #5e4fa2

    if (t < 0.111) return mix(c0, c1, t / 0.111);
    if (t < 0.222) return mix(c1, c2, (t - 0.111) / 0.111);
    if (t < 0.333) return mix(c2, c3, (t - 0.222) / 0.111);
    if (t < 0.444) return mix(c3, c4, (t - 0.333) / 0.111);
    if (t < 0.456) return mix(c4, c5, (t - 0.444) / 0.012);
    if (t < 0.504) return mix(c5, c6, (t - 0.456) / 0.048);
    if (t < 0.556) return mix(c6, c7, (t - 0.504) / 0.052);
    if (t < 0.667) return mix(c7, c8, (t - 0.556) / 0.111);
    if (t < 0.680) return mix(c8, c9, (t - 0.667) / 0.013);
    if (t < 0.889) return mix(c9, c10, (t - 0.680) / 0.209);
    return mix(c10, c11, (t - 0.889) / 0.111);
}

// --- MATH HELPERS ---

// Rotate a vector around Y axis
vec3 rotateY(vec3 p, float a) {
    float c = cos(a);
    float s = sin(a);
    return vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);
}

// Rotate a vector around X axis
vec3 rotateX(vec3 p, float a) {
    float c = cos(a);
    float s = sin(a);
    return vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);
}

// --- DISTANCE ESTIMATOR (THE MANDELORUS) ---
// Returns vec2(Distance, SmoothIteration)

vec2 map(vec3 p) {
    vec3 z = p;
    vec3 c = p;
    
    float dr = 1.0;
    float iter = 0.0;
    
    // Config values
    float R = RingRadius;
    float pwr = Power;
    
    for (int i = 0; i < Iterations; i++) {
        // 1. TOROIDAL DECOMPOSITION
        float lenXY = length(z.xy);
        float phi = atan(z.y, z.x);
        
        vec2 q = vec2(lenXY - R, z.z * VertScale);
        
        // 2. TWIST
        if (abs(Twist) > 0.001) {
            float rotAng = phi * Twist;
            float s = sin(rotAng);
            float co = cos(rotAng);
            q = mat2(co, -s, s, co) * q;
        }
        
        // 3. COMPLEX POWER
        float r2 = dot(q, q);
        if (r2 > Bailout) {
            // Smooth Iteration Calculation for Escape Time
            // Doubling formula approximation
            iter = float(i) + 1.0 - log(log(sqrt(r2))) / log(pwr);
            break;
        }
        
        iter = float(i);
        
        float r = sqrt(r2);
        float angleQ = atan(q.y, q.x);
        
        angleQ += CrossPhase;
        
        // 4. DERIVATIVE
        float dr_cross = pwr * pow(r, pwr - 1.0);
        float expansion = max(pwr, dr_cross);
        expansion *= max(1.0, VertScale);
        dr = dr * expansion + 1.0;
        
        // Power the Cross Section
        float newR = pow(r, pwr);
        float newAngleQ = angleQ * pwr;
        q = newR * vec2(cos(newAngleQ), sin(newAngleQ));
        
        // 5. SOLENOID WRAP
        phi = phi * pwr + RingPhase;
        
        // 6. RECONSTRUCTION
        vec2 ringPos = vec2(cos(phi), sin(phi));
        z.xy = ringPos * (R + q.x);
        z.z = q.y;
        
        // 7. ADDITION
        z += c;
    }
    
    // Distance Estimation
    float r = length(z);
    float d = 0.5 * log(r) * r / dr;
    
    return vec2(d, iter);
}

// --- RAYMARCHING ---

vec2 raymarch(vec3 ro, vec3 rd) {
    float dO = 0.0;
    float iter = 0.0;
    
    for(int i=0; i<MAX_ITER; i++) {
        vec3 p = ro + rd * dO;
        vec2 dS = map(p); // x=Dist, y=Iter
        
        dO += dS.x;
        iter = dS.y;
        
        if(dO > MAX_DIST || abs(dS.x) < EPSILON) break;
    }
    
    return vec2(dO, iter);
}

// --- LIGHTING ---

vec3 getNormal(vec3 p) {
    float d = map(p).x;
    vec2 e = vec2(.001, 0);
    vec3 n = d - vec3(
        map(p-e.xyy).x,
        map(p-e.yxy).x,
        map(p-e.yyx).x);
    return normalize(n);
}

float getSoftShadow(vec3 ro, vec3 rd, float k) {
    float res = 1.0;
    float t = 0.01;
    for(int i=0; i<32; i++) {
        float h = map(ro + rd*t).x;
        if( h<0.001 ) return 0.0;
        res = min( res, k*h/t );
        t += h;
        if( t>10.0 ) break;
    }
    return res;
}

float getAO(vec3 p, vec3 n) {
    float occ = 0.0;
    float sca = 1.0;
    for(int i=0; i<5; i++) {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  n * hr + p;
        float dd = map(aopos).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );
}

// --- MAIN LOOP ---

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;
    vec2 m = iMouse.xy/iResolution.xy;

    vec3 col = vec3(0.0);
    
    // Camera setup
    float camDist = 3.5;
    vec3 ro = vec3(0, 0, -camDist);
    
    // Mouse rotation
    if (iMouse.z > 0.0) {
        ro = rotateY(ro, m.x * 6.28);
        ro = rotateX(ro, (m.y - 0.5) * 3.14);
    } else {
        // Auto rotate if no mouse input
        ro = rotateY(ro, iTime * 0.1);
        ro = rotateX(ro, 0.4);
    }
    
    vec3 lookAt = vec3(0);
    vec3 f = normalize(lookAt - ro);
    vec3 r = normalize(cross(vec3(0,1,0), f));
    vec3 u = cross(f, r);
    vec3 rd = normalize(f + uv.x*r + uv.y*u);

    // Render
    vec2 res = raymarch(ro, rd);
    float d = res.x;
    float iter = res.y;
    
    if(d < MAX_DIST) {
        vec3 p = ro + rd * d;
        vec3 n = getNormal(p);
        
        // Headlamp Lighting: Light attached to Camera Position
        vec3 lightPos = ro + vec3(0.5, 2.0, 0.0); 
        vec3 l = normalize(lightPos - p);
        
        // Lighting Components
        float dif = clamp(dot(n, l), 0.0, 1.0);
        float sha = getSoftShadow(p + n*0.01, l, 16.0);
        float ao = getAO(p, n);
        
        // --- COLORING STRATEGY (GMT Levels Mode) ---
        
        // 1. Normalize iter (0 to Max) to 0.0-1.0
        float iterNorm = iter / float(Iterations);
        
        // 2. Apply Levels (Min/Max) to stretch the range
        // If iterNorm = Min, result is 0. If iterNorm = Max, result is 1.
        float t = (iterNorm - ColorMin) / (ColorMax - ColorMin);
        
        // 3. Apply Repeats
        t *= ColorRepeats;
        
        // 4. Wrap (Fract) so it cycles through the gradient
        // Using abs() ensures it mirrors nicely for negative values if min is high
        t = fract(t);
        
        // Use Custom Gradient from JSON
        vec3 surfaceColor = paletteCustom(t);
        
        // Combine
        vec3 linColor = surfaceColor * dif * sha * ao;
        
        // Specular Highlights
        vec3 ref = reflect(-l, n);
        float spe = pow(clamp(dot(ref, normalize(ro-p)), 0.0, 1.0), 32.0);
        linColor += spe * sha * vec3(1.0, 0.9, 0.8); // Warm specular
        
        col = linColor;
    }
    
    // Background / Fog
    // Dark void
    col = mix(col, vec3(0.02, 0.02, 0.02), 1.0 - exp(-0.01 * d * d));

    // Gamma correction
    col = pow(col, vec3(0.4545));
    
    // Slight vignette
    col *= 1.0 - 0.3 * dot(uv, uv);

    fragColor = vec4(col,1.0);
}
