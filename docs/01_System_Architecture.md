
# System Architecture

## 1. The "Engine-Bridge" Pattern

GMT is a hybrid application. It bridges two distinct execution contexts:
1.  **The Reactive UI (React/Zustand):** Event-driven, updates on user interaction.
2.  **The Render Loop (WebGL/Three.js):** Continuous, runs at 60Hz via `requestAnimationFrame`.

### The Problem
Directly binding React state to a Shader Uniform inside `useFrame` causes massive Garbage Collection (GC) pressure and React overhead, killing performance.

### The Solution
We use a **Unidirectional Push Architecture**.

1.  **State Change:** User moves a slider. Zustand updates the store.
2.  **Subscription:** The `EngineBridge` (or `createFeatureSlice` logic) subscribes to specific slice changes.
3.  **Event Bus:** Updates are emitted via `FractalEvents` (e.g., `uniform`, `config`).
4.  **Engine Update:** The Singleton `FractalEngine` receives the event and updates the `Three.js` Uniform or Internal State directly (bypassing React entirely for the frame loop).

## 2. Data-Driven Feature System (DDFS)

The application is built on a modular architecture called **DDFS**. Instead of hardcoding UI panels and state slices for every new feature, we define features in a Registry.

### 2.1 Feature Definition (`engine/FeatureSystem.ts`)
A feature (e.g., `Fog`, `Quality`) is defined as a static object containing:
*   **ID/Name:** Unique identifiers.
*   **Params:** A schema defining parameters (float, color, boolean), their defaults, and UI constraints (min/max).
*   **Shader Chunks:** GLSL code fragments to be injected into the main shader.
*   **UI Config:** Where to render the controls (which tab, order).

### 2.2 Dynamic Generation
At runtime:
1.  **State:** `createFeatureSlice.ts` iterates the registry and generates the Zustand state slice automatically.
2.  **UI:** `AutoFeaturePanel.tsx` iterates the params and renders the appropriate inputs (Sliders, Color Pickers) automatically.
3.  **Shader:** `ShaderFactory.ts` injects the uniforms and code chunks defined in the feature.

**Benefit:** Adding a new feature usually requires editing **only one file** (the feature definition file), and the rest of the engine adapts automatically.

### 2.3 Meta-Features (Orchestration)
Some features, like **Engine Settings**, do not own shader code directly but orchestrate other features.
*   **Example:** `EngineSettingsFeature` defines the "Lite Mode" vs "Ultra Mode" presets.
*   **Action:** Its `applyPreset` action batch-updates `lighting`, `quality`, `reflections`, and `atmosphere` slices simultaneously.
*   **Hardware Detection:** On boot, the `FractalEngine` constructor detects device capabilities (mobile/desktop) and initializes `quality` defaults (`precisionMode`, `bufferPrecision`). The engine also sets a runtime `isMobile` hint that flows into `ShaderConfig`/`ConfigManager` and is used by some shader chunks; prefer using the `quality` feature for precision decisions while treating `isMobile` as a runtime capability hint.

## 3. The Render Loop (`FractalEngine.ts`)

The `FractalEngine` class acts as the conductor.

1.  **Input Handling:** `components/Navigation.tsx` drives the camera math.
2.  **Update (`update()`):**
    *   Calculates "Virtual Space" coordinates (Double Precision emulation).
    *   Updates smoothers and interpolators.
3.  **Render (`render()`):**
    *   Checks the `RenderPipeline` state.
    *   If **Accumulating** (TSS): Blends the new frame with the previous frame buffer to remove noise/grain.
    *   If **Moving**: Renders a single fast frame.
4.  **Post-Process:** Passes the result through Tone Mapping (ACES) and Gamma Correction.

## 4. State Management

*   **Zustand:** Used for global state.
*   **Slices:** State is divided into:
    *   `rendererSlice` (Resolution, Export logic)
    *   `cameraSlice` (Position, Rotation)
    *   `uiSlice` (Panel visibility)
    *   `historySlice` (Undo/Redo)
    *   *Dynamic Slices* (Generated by DDFS for all shader parameters)
*   **Persistence:** The `getPreset()` and `loadPreset()` functions serialize this entire state tree into JSON.
