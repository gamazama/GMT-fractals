/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */function m(t){if(!t)throw new Error("Assertion failed.")}const ei=t=>{const e=(t%360+360)%360;if(e===0||e===90||e===180||e===270)return e;throw new Error(`Invalid rotation ${t}.`)},V=t=>t&&t[t.length-1],re=t=>t>=0&&t<2**32;class z{constructor(e){this.bytes=e,this.pos=0}seekToByte(e){this.pos=8*e}readBit(){const e=Math.floor(this.pos/8),i=this.bytes[e]??0,r=7-(this.pos&7),s=(i&1<<r)>>r;return this.pos++,s}readBits(e){if(e===1)return this.readBit();let i=0;for(let r=0;r<e;r++)i<<=1,i|=this.readBit();return i}writeBits(e,i){const r=this.pos+e;for(let s=this.pos;s<r;s++){const n=Math.floor(s/8);let o=this.bytes[n];const a=7-(s&7);o&=~(1<<a),o|=(i&1<<r-s-1)>>r-s-1<<a,this.bytes[n]=o}this.pos=r}readAlignedByte(){if(this.pos%8!==0)throw new Error("Bitstream is not byte-aligned.");const e=this.pos/8,i=this.bytes[e]??0;return this.pos+=8,i}skipBits(e){this.pos+=e}getBitsLeft(){return this.bytes.length*8-this.pos}clone(){const e=new z(this.bytes);return e.pos=this.pos,e}}const h=t=>{let e=0;for(;t.readBits(1)===0&&e<32;)e++;if(e>=32)throw new Error("Invalid exponential-Golomb code.");return(1<<e)-1+t.readBits(e)},q=t=>{const e=h(t);return e&1?e+1>>1:-(e>>1)},ti=(t,e,i,r)=>{for(let s=e;s<i;s++){const n=Math.floor(s/8);let o=t[n];const a=7-(s&7);o&=~(1<<a),o|=(r&1<<i-s-1)>>i-s-1<<a,t[n]=o}},Z=t=>t.constructor===Uint8Array?t:ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):new Uint8Array(t),yt=t=>t.constructor===DataView?t:ArrayBuffer.isView(t)?new DataView(t.buffer,t.byteOffset,t.byteLength):new DataView(t),E=new TextEncoder,ye={bt709:1,bt470bg:5,smpte170m:6,bt2020:9,smpte432:12},be={bt709:1,smpte170m:6,linear:8,"iec61966-2-1":13,pq:16,hlg:18},Te={rgb:0,bt709:1,bt470bg:5,smpte170m:6,"bt2020-ncl":9},bt=t=>!!t&&!!t.primaries&&!!t.transfer&&!!t.matrix&&t.fullRange!==void 0,Tt=t=>t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer||ArrayBuffer.isView(t);class Ct{constructor(){this.currentPromise=Promise.resolve(),this.pending=0}async acquire(){let e;const i=new Promise(s=>{let n=!1;e=()=>{n||(s(),this.pending--,n=!0)}}),r=this.currentPromise;return this.currentPromise=i,this.pending++,await r,e}}const kt=()=>{let t,e;return{promise:new Promise((r,s)=>{t=r,e=s}),resolve:t,reject:e}},Ce=t=>{throw new Error(`Unexpected value: ${t}`)},ii=(t,e,i,r)=>{i=i>>>0,i=i&16777215,t.setUint8(e,i>>>16&255),t.setUint8(e+1,i>>>8&255),t.setUint8(e+2,i&255)},St="und",Le=(t,e)=>Math.round(t/e)*e,ri=/^[a-z]{3}$/,si=t=>ri.test(t),Ge=1e6*(1+Number.EPSILON),ni=(t,e)=>{const i=t<0?-1:1;t=Math.abs(t);let r=0,s=1,n=1,o=0,a=t;for(;;){const l=Math.floor(a),u=l*n+r,c=l*o+s;if(c>e)return{numerator:i*n,denominator:o};if(r=n,s=o,n=u,o=c,a=1/(a-l),!isFinite(a))break}return{numerator:i*n,denominator:o}};let xe=null;const oi=()=>{var t;return xe!==null?xe:xe=typeof navigator<"u"&&((t=navigator.userAgent)==null?void 0:t.includes("Firefox"))},Ve=function*(t){for(const e in t){const i=t[e];i!==void 0&&(yield{key:e,value:i})}},ai=t=>{switch(t.toLowerCase()){case"image/jpeg":case"image/jpg":return".jpg";case"image/png":return".png";case"image/gif":return".gif";case"image/webp":return".webp";case"image/bmp":return".bmp";case"image/svg+xml":return".svg";case"image/tiff":return".tiff";case"image/avif":return".avif";case"image/x-icon":case"image/vnd.microsoft.icon":return".ico";default:return null}},ci=(t,e)=>{if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(t[i]!==e[i])return!1;return!0};/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class xt{constructor(e,i){if(this.data=e,this.mimeType=i,!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(typeof i!="string")throw new TypeError("mimeType must be a string.")}}class _t{constructor(e,i,r,s){if(this.data=e,this.mimeType=i,this.name=r,this.description=s,!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(i!==void 0&&typeof i!="string")throw new TypeError("mimeType, when provided, must be a string.");if(r!==void 0&&typeof r!="string")throw new TypeError("name, when provided, must be a string.");if(s!==void 0&&typeof s!="string")throw new TypeError("description, when provided, must be a string.")}}const li=t=>{if(!t||typeof t!="object")throw new TypeError("tags must be an object.");if(t.title!==void 0&&typeof t.title!="string")throw new TypeError("tags.title, when provided, must be a string.");if(t.description!==void 0&&typeof t.description!="string")throw new TypeError("tags.description, when provided, must be a string.");if(t.artist!==void 0&&typeof t.artist!="string")throw new TypeError("tags.artist, when provided, must be a string.");if(t.album!==void 0&&typeof t.album!="string")throw new TypeError("tags.album, when provided, must be a string.");if(t.albumArtist!==void 0&&typeof t.albumArtist!="string")throw new TypeError("tags.albumArtist, when provided, must be a string.");if(t.trackNumber!==void 0&&(!Number.isInteger(t.trackNumber)||t.trackNumber<=0))throw new TypeError("tags.trackNumber, when provided, must be a positive integer.");if(t.tracksTotal!==void 0&&(!Number.isInteger(t.tracksTotal)||t.tracksTotal<=0))throw new TypeError("tags.tracksTotal, when provided, must be a positive integer.");if(t.discNumber!==void 0&&(!Number.isInteger(t.discNumber)||t.discNumber<=0))throw new TypeError("tags.discNumber, when provided, must be a positive integer.");if(t.discsTotal!==void 0&&(!Number.isInteger(t.discsTotal)||t.discsTotal<=0))throw new TypeError("tags.discsTotal, when provided, must be a positive integer.");if(t.genre!==void 0&&typeof t.genre!="string")throw new TypeError("tags.genre, when provided, must be a string.");if(t.date!==void 0&&(!(t.date instanceof Date)||Number.isNaN(t.date.getTime())))throw new TypeError("tags.date, when provided, must be a valid Date.");if(t.lyrics!==void 0&&typeof t.lyrics!="string")throw new TypeError("tags.lyrics, when provided, must be a string.");if(t.images!==void 0){if(!Array.isArray(t.images))throw new TypeError("tags.images, when provided, must be an array.");for(const e of t.images){if(!e||typeof e!="object")throw new TypeError("Each image in tags.images must be an object.");if(!(e.data instanceof Uint8Array))throw new TypeError("Each image.data must be a Uint8Array.");if(typeof e.mimeType!="string")throw new TypeError("Each image.mimeType must be a string.");if(!["coverFront","coverBack","unknown"].includes(e.kind))throw new TypeError("Each image.kind must be 'coverFront', 'coverBack', or 'unknown'.")}}if(t.comment!==void 0&&typeof t.comment!="string")throw new TypeError("tags.comment, when provided, must be a string.");if(t.raw!==void 0){if(!t.raw||typeof t.raw!="object")throw new TypeError("tags.raw, when provided, must be an object.");for(const e of Object.values(t.raw))if(e!==null&&typeof e!="string"&&!(e instanceof Uint8Array)&&!(e instanceof xt)&&!(e instanceof _t))throw new TypeError("Each value in tags.raw must be a string, Uint8Array, RichImageData, AttachedFile, or null.")}},ui=t=>{if(!t||typeof t!="object")throw new TypeError("disposition must be an object.");if(t.default!==void 0&&typeof t.default!="boolean")throw new TypeError("disposition.default must be a boolean.");if(t.forced!==void 0&&typeof t.forced!="boolean")throw new TypeError("disposition.forced must be a boolean.");if(t.original!==void 0&&typeof t.original!="boolean")throw new TypeError("disposition.original must be a boolean.");if(t.commentary!==void 0&&typeof t.commentary!="boolean")throw new TypeError("disposition.commentary must be a boolean.");if(t.hearingImpaired!==void 0&&typeof t.hearingImpaired!="boolean")throw new TypeError("disposition.hearingImpaired must be a boolean.");if(t.visuallyImpaired!==void 0&&typeof t.visuallyImpaired!="boolean")throw new TypeError("disposition.visuallyImpaired must be a boolean.")};/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const J=["avc","hevc","vp9","av1","vp8"],Q=["pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be","pcm-u8","pcm-s8","ulaw","alaw"],Oe=["aac","opus","mp3","vorbis","flac","ac3","eac3"],de=[...Oe,...Q],se=["webvtt"],me=[{maxMacroblocks:99,maxBitrate:64e3,maxDpbMbs:396,level:10},{maxMacroblocks:396,maxBitrate:192e3,maxDpbMbs:900,level:11},{maxMacroblocks:396,maxBitrate:384e3,maxDpbMbs:2376,level:12},{maxMacroblocks:396,maxBitrate:768e3,maxDpbMbs:2376,level:13},{maxMacroblocks:396,maxBitrate:2e6,maxDpbMbs:2376,level:20},{maxMacroblocks:792,maxBitrate:4e6,maxDpbMbs:4752,level:21},{maxMacroblocks:1620,maxBitrate:4e6,maxDpbMbs:8100,level:22},{maxMacroblocks:1620,maxBitrate:1e7,maxDpbMbs:8100,level:30},{maxMacroblocks:3600,maxBitrate:14e6,maxDpbMbs:18e3,level:31},{maxMacroblocks:5120,maxBitrate:2e7,maxDpbMbs:20480,level:32},{maxMacroblocks:8192,maxBitrate:2e7,maxDpbMbs:32768,level:40},{maxMacroblocks:8192,maxBitrate:5e7,maxDpbMbs:32768,level:41},{maxMacroblocks:8704,maxBitrate:5e7,maxDpbMbs:34816,level:42},{maxMacroblocks:22080,maxBitrate:135e6,maxDpbMbs:110400,level:50},{maxMacroblocks:36864,maxBitrate:24e7,maxDpbMbs:184320,level:51},{maxMacroblocks:36864,maxBitrate:24e7,maxDpbMbs:184320,level:52},{maxMacroblocks:139264,maxBitrate:24e7,maxDpbMbs:696320,level:60},{maxMacroblocks:139264,maxBitrate:48e7,maxDpbMbs:696320,level:61},{maxMacroblocks:139264,maxBitrate:8e8,maxDpbMbs:696320,level:62}],Ke=[{maxPictureSize:36864,maxBitrate:128e3,tier:"L",level:30},{maxPictureSize:122880,maxBitrate:15e5,tier:"L",level:60},{maxPictureSize:245760,maxBitrate:3e6,tier:"L",level:63},{maxPictureSize:552960,maxBitrate:6e6,tier:"L",level:90},{maxPictureSize:983040,maxBitrate:1e7,tier:"L",level:93},{maxPictureSize:2228224,maxBitrate:12e6,tier:"L",level:120},{maxPictureSize:2228224,maxBitrate:3e7,tier:"H",level:120},{maxPictureSize:2228224,maxBitrate:2e7,tier:"L",level:123},{maxPictureSize:2228224,maxBitrate:5e7,tier:"H",level:123},{maxPictureSize:8912896,maxBitrate:25e6,tier:"L",level:150},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:150},{maxPictureSize:8912896,maxBitrate:4e7,tier:"L",level:153},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:153},{maxPictureSize:8912896,maxBitrate:6e7,tier:"L",level:156},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:156},{maxPictureSize:35651584,maxBitrate:6e7,tier:"L",level:180},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:180},{maxPictureSize:35651584,maxBitrate:12e7,tier:"L",level:183},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:183},{maxPictureSize:35651584,maxBitrate:24e7,tier:"L",level:186},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:186}],Xe=[{maxPictureSize:36864,maxBitrate:2e5,level:10},{maxPictureSize:73728,maxBitrate:8e5,level:11},{maxPictureSize:122880,maxBitrate:18e5,level:20},{maxPictureSize:245760,maxBitrate:36e5,level:21},{maxPictureSize:552960,maxBitrate:72e5,level:30},{maxPictureSize:983040,maxBitrate:12e6,level:31},{maxPictureSize:2228224,maxBitrate:18e6,level:40},{maxPictureSize:2228224,maxBitrate:3e7,level:41},{maxPictureSize:8912896,maxBitrate:6e7,level:50},{maxPictureSize:8912896,maxBitrate:12e7,level:51},{maxPictureSize:8912896,maxBitrate:18e7,level:52},{maxPictureSize:35651584,maxBitrate:18e7,level:60},{maxPictureSize:35651584,maxBitrate:24e7,level:61},{maxPictureSize:35651584,maxBitrate:48e7,level:62}],Ye=[{maxPictureSize:147456,maxBitrate:15e5,tier:"M",level:0},{maxPictureSize:278784,maxBitrate:3e6,tier:"M",level:1},{maxPictureSize:665856,maxBitrate:6e6,tier:"M",level:4},{maxPictureSize:1065024,maxBitrate:1e7,tier:"M",level:5},{maxPictureSize:2359296,maxBitrate:12e6,tier:"M",level:8},{maxPictureSize:2359296,maxBitrate:3e7,tier:"H",level:8},{maxPictureSize:2359296,maxBitrate:2e7,tier:"M",level:9},{maxPictureSize:2359296,maxBitrate:5e7,tier:"H",level:9},{maxPictureSize:8912896,maxBitrate:3e7,tier:"M",level:12},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:12},{maxPictureSize:8912896,maxBitrate:4e7,tier:"M",level:13},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:13},{maxPictureSize:8912896,maxBitrate:6e7,tier:"M",level:14},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:14},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:15},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:15},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:16},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:16},{maxPictureSize:35651584,maxBitrate:1e8,tier:"M",level:17},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:17},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:18},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:18},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:19},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:19}],di=(t,e,i,r)=>{if(t==="avc"){const n=Math.ceil(e/16)*Math.ceil(i/16),o=me.find(p=>n<=p.maxMacroblocks&&r<=p.maxBitrate)??V(me),a=o?o.level:0,l="64".padStart(2,"0"),u="00",c=a.toString(16).padStart(2,"0");return`avc1.${l}${u}${c}`}else if(t==="hevc"){const s="",o="6",a=e*i,l=Ke.find(c=>a<=c.maxPictureSize&&r<=c.maxBitrate)??V(Ke);return`hev1.${s}1.${o}.${l.tier}${l.level}.B0`}else{if(t==="vp8")return"vp8";if(t==="vp9"){const s="00",n=e*i,o=Xe.find(l=>n<=l.maxPictureSize&&r<=l.maxBitrate)??V(Xe);return`vp09.${s}.${o.level.toString().padStart(2,"0")}.08`}else if(t==="av1"){const n=e*i,o=Ye.find(u=>n<=u.maxPictureSize&&r<=u.maxBitrate)??V(Ye);return`av01.0.${o.level.toString().padStart(2,"0")}${o.tier}.08`}}throw new TypeError(`Unhandled codec '${t}'.`)},fi=t=>{const e=t.split("."),i=Number(e[1]),r=Number(e[2]),s=Number(e[3]),n=e[4]?Number(e[4]):1;return[1,1,i,2,1,r,3,1,s,4,1,n]},vt=t=>{const e=t.split("."),s=(1<<7)+1,n=Number(e[1]),o=e[2],a=Number(o.slice(0,-1)),l=(n<<5)+a,u=o.slice(-1)==="H"?1:0,p=Number(e[3])===8?0:1,b=0,y=e[4]?Number(e[4]):0,T=e[5]?Number(e[5][0]):1,S=e[5]?Number(e[5][1]):1,B=e[5]?Number(e[5][2]):0,H=(u<<7)+(p<<6)+(b<<5)+(y<<4)+(T<<3)+(S<<2)+B;return[s,l,H,0]},Re=[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350],Ie=[-1,1,2,3,4,5,6,8],Pt=t=>{let e=Re.indexOf(t.sampleRate),i=null;e===-1&&(e=15,i=t.sampleRate);const r=Ie.indexOf(t.numberOfChannels);if(r===-1)throw new TypeError(`Unsupported number of channels: ${t.numberOfChannels}`);let s=13;t.objectType>=32&&(s+=6),e===15&&(s+=24);const n=Math.ceil(s/8),o=new Uint8Array(n),a=new z(o);return t.objectType<32?a.writeBits(5,t.objectType):(a.writeBits(5,31),a.writeBits(6,t.objectType-32)),a.writeBits(4,e),e===15&&a.writeBits(24,i),a.writeBits(4,r),o},hi=48e3,At=/^pcm-([usf])(\d+)+(be)?$/,ne=t=>{if(m(Q.includes(t)),t==="ulaw")return{dataType:"ulaw",sampleSize:1,littleEndian:!0,silentValue:255};if(t==="alaw")return{dataType:"alaw",sampleSize:1,littleEndian:!0,silentValue:213};const e=At.exec(t);m(e);let i;e[1]==="u"?i="unsigned":e[1]==="s"?i="signed":i="float";const r=Number(e[2])/8,s=e[3]!=="be",n=t==="pcm-u8"?2**7:0;return{dataType:i,sampleSize:r,littleEndian:s,silentValue:n}},mi=t=>t.startsWith("avc1")||t.startsWith("avc3")?"avc":t.startsWith("hev1")||t.startsWith("hvc1")?"hevc":t==="vp8"?"vp8":t.startsWith("vp09")?"vp9":t.startsWith("av01")?"av1":t.startsWith("mp4a.40")||t==="mp4a.67"?"aac":t==="mp3"||t==="mp4a.69"||t==="mp4a.6B"||t==="mp4a.6b"?"mp3":t==="opus"?"opus":t==="vorbis"?"vorbis":t==="flac"?"flac":t==="ac-3"||t==="ac3"?"ac3":t==="ec-3"||t==="eac3"?"eac3":t==="ulaw"?"ulaw":t==="alaw"?"alaw":At.test(t)?t:t==="webvtt"?"webvtt":null,pi=t=>t==="avc"?{avc:{format:"avc"}}:t==="hevc"?{hevc:{format:"hevc"}}:{},gi=["avc1","avc3","hev1","hvc1","vp8","vp09","av01"],wi=/^(avc1|avc3)\.[0-9a-fA-F]{6}$/,yi=/^(hev1|hvc1)\.(?:[ABC]?\d+)\.[0-9a-fA-F]{1,8}\.[LH]\d+(?:\.[0-9a-fA-F]{1,2}){0,6}$/,bi=/^vp09(?:\.\d{2}){3}(?:(?:\.\d{2}){5})?$/,Ti=/^av01\.\d\.\d{2}[MH]\.\d{2}(?:\.\d\.\d{3}\.\d{2}\.\d{2}\.\d{2}\.\d)?$/,Et=t=>{if(!t)throw new TypeError("Video chunk metadata must be provided.");if(typeof t!="object")throw new TypeError("Video chunk metadata must be an object.");if(!t.decoderConfig)throw new TypeError("Video chunk metadata must include a decoder configuration.");if(typeof t.decoderConfig!="object")throw new TypeError("Video chunk metadata decoder configuration must be an object.");if(typeof t.decoderConfig.codec!="string")throw new TypeError("Video chunk metadata decoder configuration must specify a codec string.");if(!gi.some(e=>t.decoderConfig.codec.startsWith(e)))throw new TypeError("Video chunk metadata decoder configuration codec string must be a valid video codec string as specified in the Mediabunny Codec Registry.");if(!Number.isInteger(t.decoderConfig.codedWidth)||t.decoderConfig.codedWidth<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).");if(!Number.isInteger(t.decoderConfig.codedHeight)||t.decoderConfig.codedHeight<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).");if(t.decoderConfig.description!==void 0&&!Tt(t.decoderConfig.description))throw new TypeError("Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(t.decoderConfig.colorSpace!==void 0){const{colorSpace:e}=t.decoderConfig;if(typeof e!="object")throw new TypeError("Video chunk metadata decoder configuration colorSpace, when provided, must be an object.");const i=Object.keys(ye);if(e.primaries!=null&&!i.includes(e.primaries))throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of ${i.join(", ")}.`);const r=Object.keys(be);if(e.transfer!=null&&!r.includes(e.transfer))throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of ${r.join(", ")}.`);const s=Object.keys(Te);if(e.matrix!=null&&!s.includes(e.matrix))throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of ${s.join(", ")}.`);if(e.fullRange!=null&&typeof e.fullRange!="boolean")throw new TypeError("Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.")}if(t.decoderConfig.codec.startsWith("avc1")||t.decoderConfig.codec.startsWith("avc3")){if(!wi.test(t.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for AVC must be a valid AVC codec string as specified in Section 3.4 of RFC 6381.")}else if(t.decoderConfig.codec.startsWith("hev1")||t.decoderConfig.codec.startsWith("hvc1")){if(!yi.test(t.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for HEVC must be a valid HEVC codec string as specified in Section E.3 of ISO 14496-15.")}else if(t.decoderConfig.codec.startsWith("vp8")){if(t.decoderConfig.codec!=="vp8")throw new TypeError('Video chunk metadata decoder configuration codec string for VP8 must be "vp8".')}else if(t.decoderConfig.codec.startsWith("vp09")){if(!bi.test(t.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for VP9 must be a valid VP9 codec string as specified in Section "Codecs Parameter String" of https://www.webmproject.org/vp9/mp4/.')}else if(t.decoderConfig.codec.startsWith("av01")&&!Ti.test(t.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for AV1 must be a valid AV1 codec string as specified in Section "Codecs Parameter String" of https://aomediacodec.github.io/av1-isobmff/.')},Ci=["mp4a","mp3","opus","vorbis","flac","ulaw","alaw","pcm","ac-3","ec-3"],Bt=t=>{if(!t)throw new TypeError("Audio chunk metadata must be provided.");if(typeof t!="object")throw new TypeError("Audio chunk metadata must be an object.");if(!t.decoderConfig)throw new TypeError("Audio chunk metadata must include a decoder configuration.");if(typeof t.decoderConfig!="object")throw new TypeError("Audio chunk metadata decoder configuration must be an object.");if(typeof t.decoderConfig.codec!="string")throw new TypeError("Audio chunk metadata decoder configuration must specify a codec string.");if(!Ci.some(e=>t.decoderConfig.codec.startsWith(e)))throw new TypeError("Audio chunk metadata decoder configuration codec string must be a valid audio codec string as specified in the Mediabunny Codec Registry.");if(!Number.isInteger(t.decoderConfig.sampleRate)||t.decoderConfig.sampleRate<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).");if(!Number.isInteger(t.decoderConfig.numberOfChannels)||t.decoderConfig.numberOfChannels<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).");if(t.decoderConfig.description!==void 0&&!Tt(t.decoderConfig.description))throw new TypeError("Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(t.decoderConfig.codec.startsWith("mp4a")&&t.decoderConfig.codec!=="mp4a.69"&&t.decoderConfig.codec!=="mp4a.6B"&&t.decoderConfig.codec!=="mp4a.6b"){if(!["mp4a.40.2","mp4a.40.02","mp4a.40.5","mp4a.40.05","mp4a.40.29","mp4a.67"].includes(t.decoderConfig.codec))throw new TypeError("Audio chunk metadata decoder configuration codec string for AAC must be a valid AAC codec string as specified in https://www.w3.org/TR/webcodecs-aac-codec-registration/.")}else if(t.decoderConfig.codec.startsWith("mp3")||t.decoderConfig.codec.startsWith("mp4a")){if(t.decoderConfig.codec!=="mp3"&&t.decoderConfig.codec!=="mp4a.69"&&t.decoderConfig.codec!=="mp4a.6B"&&t.decoderConfig.codec!=="mp4a.6b")throw new TypeError('Audio chunk metadata decoder configuration codec string for MP3 must be "mp3", "mp4a.69" or "mp4a.6B".')}else if(t.decoderConfig.codec.startsWith("opus")){if(t.decoderConfig.codec!=="opus")throw new TypeError('Audio chunk metadata decoder configuration codec string for Opus must be "opus".');if(t.decoderConfig.description&&t.decoderConfig.description.byteLength<18)throw new TypeError("Audio chunk metadata decoder configuration description, when specified, is expected to be an Identification Header as specified in Section 5.1 of RFC 7845.")}else if(t.decoderConfig.codec.startsWith("vorbis")){if(t.decoderConfig.codec!=="vorbis")throw new TypeError('Audio chunk metadata decoder configuration codec string for Vorbis must be "vorbis".');if(!t.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for Vorbis must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-vorbis-codec-registration/.")}else if(t.decoderConfig.codec.startsWith("flac")){if(t.decoderConfig.codec!=="flac")throw new TypeError('Audio chunk metadata decoder configuration codec string for FLAC must be "flac".');if(!t.decoderConfig.description||t.decoderConfig.description.byteLength<42)throw new TypeError("Audio chunk metadata decoder configuration for FLAC must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-flac-codec-registration/.")}else if(t.decoderConfig.codec.startsWith("ac-3")||t.decoderConfig.codec.startsWith("ac3")){if(t.decoderConfig.codec!=="ac-3")throw new TypeError('Audio chunk metadata decoder configuration codec string for AC-3 must be "ac-3".')}else if(t.decoderConfig.codec.startsWith("ec-3")||t.decoderConfig.codec.startsWith("eac3")){if(t.decoderConfig.codec!=="ec-3")throw new TypeError('Audio chunk metadata decoder configuration codec string for EC-3 must be "ec-3".')}else if((t.decoderConfig.codec.startsWith("pcm")||t.decoderConfig.codec.startsWith("ulaw")||t.decoderConfig.codec.startsWith("alaw"))&&!Q.includes(t.decoderConfig.codec))throw new TypeError(`Audio chunk metadata decoder configuration codec string for PCM must be one of the supported PCM codecs (${Q.join(", ")}).`)},Ft=t=>{if(!t)throw new TypeError("Subtitle metadata must be provided.");if(typeof t!="object")throw new TypeError("Subtitle metadata must be an object.");if(!t.config)throw new TypeError("Subtitle metadata must include a config object.");if(typeof t.config!="object")throw new TypeError("Subtitle metadata config must be an object.");if(typeof t.config.description!="string")throw new TypeError("Subtitle metadata config description must be a string.")};/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const ki=[48e3,44100,32e3],Si=[24e3,22050,16e3];/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var ue;(function(t){t[t.NON_IDR_SLICE=1]="NON_IDR_SLICE",t[t.SLICE_DPA=2]="SLICE_DPA",t[t.SLICE_DPB=3]="SLICE_DPB",t[t.SLICE_DPC=4]="SLICE_DPC",t[t.IDR=5]="IDR",t[t.SEI=6]="SEI",t[t.SPS=7]="SPS",t[t.PPS=8]="PPS",t[t.AUD=9]="AUD",t[t.SPS_EXT=13]="SPS_EXT"})(ue||(ue={}));var N;(function(t){t[t.RASL_N=8]="RASL_N",t[t.RASL_R=9]="RASL_R",t[t.BLA_W_LP=16]="BLA_W_LP",t[t.RSV_IRAP_VCL23=23]="RSV_IRAP_VCL23",t[t.VPS_NUT=32]="VPS_NUT",t[t.SPS_NUT=33]="SPS_NUT",t[t.PPS_NUT=34]="PPS_NUT",t[t.AUD_NUT=35]="AUD_NUT",t[t.PREFIX_SEI_NUT=39]="PREFIX_SEI_NUT",t[t.SUFFIX_SEI_NUT=40]="SUFFIX_SEI_NUT"})(N||(N={}));const We=function*(t){let e=0,i=-1;for(;e<t.length-2;){const r=t.indexOf(0,e);if(r===-1||r>=t.length-2)break;e=r;let s=0;if(e+3<t.length&&t[e+1]===0&&t[e+2]===0&&t[e+3]===1?s=4:t[e+1]===0&&t[e+2]===1&&(s=3),s===0){e++;continue}i!==-1&&e>i&&(yield{offset:i,length:e-i}),i=e+s,e=i}i!==-1&&i<t.length&&(yield{offset:i,length:t.length-i})},xi=t=>t&31,Ne=t=>{const e=[],i=t.length;for(let r=0;r<i;r++)r+2<i&&t[r]===0&&t[r+1]===0&&t[r+2]===3?(e.push(0,0),r+=2):e.push(t[r]);return new Uint8Array(e)},_i=(t,e)=>{const i=t.reduce((n,o)=>n+e+o.byteLength,0),r=new Uint8Array(i);let s=0;for(const n of t){const o=new DataView(r.buffer,r.byteOffset,r.byteLength);switch(e){case 1:o.setUint8(s,n.byteLength);break;case 2:o.setUint16(s,n.byteLength,!1);break;case 3:ii(o,s,n.byteLength);break;case 4:o.setUint32(s,n.byteLength,!1);break}s+=e,r.set(n,s),s+=n.byteLength}return r},vi=t=>{try{const e=[],i=[],r=[];for(const a of We(t)){const l=t.subarray(a.offset,a.offset+a.length),u=xi(l[0]);u===ue.SPS?e.push(l):u===ue.PPS?i.push(l):u===ue.SPS_EXT&&r.push(l)}if(e.length===0||i.length===0)return null;const s=e[0],n=Ai(s);m(n!==null);const o=n.profileIdc===100||n.profileIdc===110||n.profileIdc===122||n.profileIdc===144;return{configurationVersion:1,avcProfileIndication:n.profileIdc,profileCompatibility:n.constraintFlags,avcLevelIndication:n.levelIdc,lengthSizeMinusOne:3,sequenceParameterSets:e,pictureParameterSets:i,chromaFormat:o?n.chromaFormatIdc:null,bitDepthLumaMinus8:o?n.bitDepthLumaMinus8:null,bitDepthChromaMinus8:o?n.bitDepthChromaMinus8:null,sequenceParameterSetExt:o?r:null}}catch(e){return console.error("Error building AVC Decoder Configuration Record:",e),null}},Pi=t=>{const e=[];e.push(t.configurationVersion),e.push(t.avcProfileIndication),e.push(t.profileCompatibility),e.push(t.avcLevelIndication),e.push(252|t.lengthSizeMinusOne&3),e.push(224|t.sequenceParameterSets.length&31);for(const i of t.sequenceParameterSets){const r=i.byteLength;e.push(r>>8),e.push(r&255);for(let s=0;s<r;s++)e.push(i[s])}e.push(t.pictureParameterSets.length);for(const i of t.pictureParameterSets){const r=i.byteLength;e.push(r>>8),e.push(r&255);for(let s=0;s<r;s++)e.push(i[s])}if(t.avcProfileIndication===100||t.avcProfileIndication===110||t.avcProfileIndication===122||t.avcProfileIndication===144){m(t.chromaFormat!==null),m(t.bitDepthLumaMinus8!==null),m(t.bitDepthChromaMinus8!==null),m(t.sequenceParameterSetExt!==null),e.push(252|t.chromaFormat&3),e.push(248|t.bitDepthLumaMinus8&7),e.push(248|t.bitDepthChromaMinus8&7),e.push(t.sequenceParameterSetExt.length);for(const i of t.sequenceParameterSetExt){const r=i.byteLength;e.push(r>>8),e.push(r&255);for(let s=0;s<r;s++)e.push(i[s])}}return new Uint8Array(e)},Ai=t=>{try{const e=new z(Ne(t));if(e.skipBits(1),e.skipBits(2),e.readBits(5)!==7)return null;const r=e.readAlignedByte(),s=e.readAlignedByte(),n=e.readAlignedByte();h(e);let o=1,a=0,l=0,u=0;if((r===100||r===110||r===122||r===244||r===44||r===83||r===86||r===118||r===128)&&(o=h(e),o===3&&(u=e.readBits(1)),a=h(e),l=h(e),e.skipBits(1),e.readBits(1))){for(let x=0;x<(o!==3?8:12);x++)if(e.readBits(1)){const G=x<6?16:64;let F=8,v=8;for(let M=0;M<G;M++){if(v!==0){const ee=q(e);v=(F+ee+256)%256}F=v===0?F:v}}}h(e);const c=h(e);if(c===0)h(e);else if(c===1){e.skipBits(1),q(e),q(e);const O=h(e);for(let x=0;x<O;x++)q(e)}h(e),e.skipBits(1);const p=h(e),b=h(e),y=16*(p+1),T=16*(b+1);let S=y,B=T;const H=e.readBits(1);if(H||e.skipBits(1),e.skipBits(1),e.readBits(1)){const O=h(e),x=h(e),R=h(e),G=h(e);let F,v;if((u===0?o:0)===0)F=1,v=2-H;else{const ee=o===3?1:2,Se=o===1?2:1;F=ee,v=Se*(2-H)}S-=F*(O+x),B-=v*(R+G)}let oe=2,ae=2,fe=2,ce=0,L=null,$=null;if(e.readBits(1)){e.readBits(1)&&e.readBits(8)===255&&(e.skipBits(16),e.skipBits(16)),e.readBits(1)&&e.skipBits(1),e.readBits(1)&&(e.skipBits(3),ce=e.readBits(1),e.readBits(1)&&(oe=e.readBits(8),ae=e.readBits(8),fe=e.readBits(8))),e.readBits(1)&&(h(e),h(e)),e.readBits(1)&&(e.skipBits(32),e.skipBits(32),e.skipBits(1));const v=e.readBits(1);v&&Ze(e);const M=e.readBits(1);M&&Ze(e),(v||M)&&e.skipBits(1),e.skipBits(1),e.readBits(1)&&(e.skipBits(1),h(e),h(e),h(e),h(e),L=h(e),$=h(e))}if(L===null){m($===null);const O=s&16;if((r===44||r===86||r===100||r===110||r===122||r===244)&&O)L=0,$=0;else{const x=p+1,R=b+1,G=(2-H)*R,F=me.find(M=>M.level>=n)??V(me),v=Math.min(Math.floor(F.maxDpbMbs/(x*G)),16);L=v,$=v}}return m($!==null),{profileIdc:r,constraintFlags:s,levelIdc:n,frameMbsOnlyFlag:H,chromaFormatIdc:o,bitDepthLumaMinus8:a,bitDepthChromaMinus8:l,codedWidth:y,codedHeight:T,displayWidth:S,displayHeight:B,colourPrimaries:oe,matrixCoefficients:fe,transferCharacteristics:ae,fullRangeFlag:ce,numReorderFrames:L,maxDecFrameBuffering:$}}catch(e){return console.error("Error parsing AVC SPS:",e),null}},Ze=t=>{const e=h(t);t.skipBits(4),t.skipBits(4);for(let i=0;i<=e;i++)h(t),h(t),t.skipBits(1);t.skipBits(5),t.skipBits(5),t.skipBits(5),t.skipBits(5)},Je=t=>t>>1&63,Ei=t=>{try{const e=new z(Ne(t));e.skipBits(16),e.readBits(4);const i=e.readBits(3),r=e.readBits(1),{general_profile_space:s,general_tier_flag:n,general_profile_idc:o,general_profile_compatibility_flags:a,general_constraint_indicator_flags:l,general_level_idc:u}=Fi(e,i);h(e);const c=h(e);let p=0;c===3&&(p=e.readBits(1));const b=h(e),y=h(e);let T=b,S=y;if(e.readBits(1)){const x=h(e),R=h(e),G=h(e),F=h(e);let v=1,M=1;const ee=p===0?c:0;ee===1?(v=2,M=2):ee===2&&(v=2,M=1),T-=(x+R)*v,S-=(G+F)*M}const B=h(e),H=h(e);h(e);const oe=e.readBits(1)?0:i;let ae=0;for(let x=oe;x<=i;x++)h(e),ae=h(e),h(e);h(e),h(e),h(e),h(e),h(e),h(e),e.readBits(1)&&e.readBits(1)&&Mi(e),e.skipBits(1),e.skipBits(1),e.readBits(1)&&(e.skipBits(4),e.skipBits(4),h(e),h(e),e.skipBits(1));const fe=h(e);if(zi(e,fe),e.readBits(1)){const x=h(e);for(let R=0;R<x;R++)h(e),e.skipBits(1)}e.skipBits(1),e.skipBits(1);let ce=2,L=2,$=2,ke=0,O=0;if(e.readBits(1)){const x=Vi(e,i);ce=x.colourPrimaries,L=x.transferCharacteristics,$=x.matrixCoefficients,ke=x.fullRangeFlag,O=x.minSpatialSegmentationIdc}return{displayWidth:T,displayHeight:S,colourPrimaries:ce,transferCharacteristics:L,matrixCoefficients:$,fullRangeFlag:ke,maxDecFrameBuffering:ae+1,spsMaxSubLayersMinus1:i,spsTemporalIdNestingFlag:r,generalProfileSpace:s,generalTierFlag:n,generalProfileIdc:o,generalProfileCompatibilityFlags:a,generalConstraintIndicatorFlags:l,generalLevelIdc:u,chromaFormatIdc:c,bitDepthLumaMinus8:B,bitDepthChromaMinus8:H,minSpatialSegmentationIdc:O}}catch(e){return console.error("Error parsing HEVC SPS:",e),null}},Bi=t=>{try{const e=[],i=[],r=[],s=[];for(const u of We(t)){const c=t.subarray(u.offset,u.offset+u.length),p=Je(c[0]);p===N.VPS_NUT?e.push(c):p===N.SPS_NUT?i.push(c):p===N.PPS_NUT?r.push(c):(p===N.PREFIX_SEI_NUT||p===N.SUFFIX_SEI_NUT)&&s.push(c)}if(i.length===0||r.length===0)return null;const n=Ei(i[0]);if(!n)return null;let o=0;if(r.length>0){const u=r[0],c=new z(Ne(u));c.skipBits(16),h(c),h(c),c.skipBits(1),c.skipBits(1),c.skipBits(3),c.skipBits(1),c.skipBits(1),h(c),h(c),q(c),c.skipBits(1),c.skipBits(1),c.readBits(1)&&h(c),q(c),q(c),c.skipBits(1),c.skipBits(1),c.skipBits(1),c.skipBits(1);const p=c.readBits(1),b=c.readBits(1);!p&&!b?o=0:p&&!b?o=2:!p&&b?o=3:o=0}const a=[...e.length?[{arrayCompleteness:1,nalUnitType:N.VPS_NUT,nalUnits:e}]:[],...i.length?[{arrayCompleteness:1,nalUnitType:N.SPS_NUT,nalUnits:i}]:[],...r.length?[{arrayCompleteness:1,nalUnitType:N.PPS_NUT,nalUnits:r}]:[],...s.length?[{arrayCompleteness:1,nalUnitType:Je(s[0][0]),nalUnits:s}]:[]];return{configurationVersion:1,generalProfileSpace:n.generalProfileSpace,generalTierFlag:n.generalTierFlag,generalProfileIdc:n.generalProfileIdc,generalProfileCompatibilityFlags:n.generalProfileCompatibilityFlags,generalConstraintIndicatorFlags:n.generalConstraintIndicatorFlags,generalLevelIdc:n.generalLevelIdc,minSpatialSegmentationIdc:n.minSpatialSegmentationIdc,parallelismType:o,chromaFormatIdc:n.chromaFormatIdc,bitDepthLumaMinus8:n.bitDepthLumaMinus8,bitDepthChromaMinus8:n.bitDepthChromaMinus8,avgFrameRate:0,constantFrameRate:0,numTemporalLayers:n.spsMaxSubLayersMinus1+1,temporalIdNested:n.spsTemporalIdNestingFlag,lengthSizeMinusOne:3,arrays:a}}catch(e){return console.error("Error building HEVC Decoder Configuration Record:",e),null}},Fi=(t,e)=>{const i=t.readBits(2),r=t.readBits(1),s=t.readBits(5);let n=0;for(let c=0;c<32;c++)n=n<<1|t.readBits(1);const o=new Uint8Array(6);for(let c=0;c<6;c++)o[c]=t.readBits(8);const a=t.readBits(8),l=[],u=[];for(let c=0;c<e;c++)l.push(t.readBits(1)),u.push(t.readBits(1));if(e>0)for(let c=e;c<8;c++)t.skipBits(2);for(let c=0;c<e;c++)l[c]&&t.skipBits(88),u[c]&&t.skipBits(8);return{general_profile_space:i,general_tier_flag:r,general_profile_idc:s,general_profile_compatibility_flags:n,general_constraint_indicator_flags:o,general_level_idc:a}},Mi=t=>{for(let e=0;e<4;e++)for(let i=0;i<(e===3?2:6);i++)if(!t.readBits(1))h(t);else{const s=Math.min(64,1<<4+(e<<1));e>1&&q(t);for(let n=0;n<s;n++)q(t)}},zi=(t,e)=>{const i=[];for(let r=0;r<e;r++)i[r]=Ui(t,r,e,i)},Ui=(t,e,i,r)=>{let s=0,n=0,o=0;if(e!==0&&(n=t.readBits(1)),n){if(e===i){const l=h(t);o=e-(l+1)}else o=e-1;t.readBits(1),h(t);const a=r[o]??0;for(let l=0;l<=a;l++)t.readBits(1)||t.readBits(1);s=r[o]}else{const a=h(t),l=h(t);for(let u=0;u<a;u++)h(t),t.readBits(1);for(let u=0;u<l;u++)h(t),t.readBits(1);s=a+l}return s},Vi=(t,e)=>{let i=2,r=2,s=2,n=0,o=0;return t.readBits(1)&&t.readBits(8)===255&&(t.readBits(16),t.readBits(16)),t.readBits(1)&&t.readBits(1),t.readBits(1)&&(t.readBits(3),n=t.readBits(1),t.readBits(1)&&(i=t.readBits(8),r=t.readBits(8),s=t.readBits(8))),t.readBits(1)&&(h(t),h(t)),t.readBits(1),t.readBits(1),t.readBits(1),t.readBits(1)&&(h(t),h(t),h(t),h(t)),t.readBits(1)&&(t.readBits(32),t.readBits(32),t.readBits(1)&&h(t),t.readBits(1)&&Oi(t,!0,e)),t.readBits(1)&&(t.readBits(1),t.readBits(1),t.readBits(1),o=h(t),h(t),h(t),h(t),h(t)),{colourPrimaries:i,transferCharacteristics:r,matrixCoefficients:s,fullRangeFlag:n,minSpatialSegmentationIdc:o}},Oi=(t,e,i)=>{let r=!1,s=!1,n=!1;r=t.readBits(1)===1,s=t.readBits(1)===1,(r||s)&&(n=t.readBits(1)===1,n&&(t.readBits(8),t.readBits(5),t.readBits(1),t.readBits(5)),t.readBits(4),t.readBits(4),n&&t.readBits(4),t.readBits(5),t.readBits(5),t.readBits(5));for(let o=0;o<=i;o++){const a=t.readBits(1)===1;let l=!0;a||(l=t.readBits(1)===1);let u=!1;l?h(t):u=t.readBits(1)===1;let c=1;u||(c=h(t)+1),r&&et(t,c,n),s&&et(t,c,n)}},et=(t,e,i)=>{for(let r=0;r<e;r++)h(t),h(t),i&&(h(t),h(t)),t.readBits(1)},Ri=t=>{const e=[];e.push(t.configurationVersion),e.push((t.generalProfileSpace&3)<<6|(t.generalTierFlag&1)<<5|t.generalProfileIdc&31),e.push(t.generalProfileCompatibilityFlags>>>24&255),e.push(t.generalProfileCompatibilityFlags>>>16&255),e.push(t.generalProfileCompatibilityFlags>>>8&255),e.push(t.generalProfileCompatibilityFlags&255),e.push(...t.generalConstraintIndicatorFlags),e.push(t.generalLevelIdc&255),e.push(240|t.minSpatialSegmentationIdc>>8&15),e.push(t.minSpatialSegmentationIdc&255),e.push(252|t.parallelismType&3),e.push(252|t.chromaFormatIdc&3),e.push(248|t.bitDepthLumaMinus8&7),e.push(248|t.bitDepthChromaMinus8&7),e.push(t.avgFrameRate>>8&255),e.push(t.avgFrameRate&255),e.push((t.constantFrameRate&3)<<6|(t.numTemporalLayers&7)<<3|(t.temporalIdNested&1)<<2|t.lengthSizeMinusOne&3),e.push(t.arrays.length&255);for(const i of t.arrays){e.push((i.arrayCompleteness&1)<<7|0|i.nalUnitType&63),e.push(i.nalUnits.length>>8&255),e.push(i.nalUnits.length&255);for(const r of i.nalUnits){e.push(r.length>>8&255),e.push(r.length&255);for(let s=0;s<r.length;s++)e.push(r[s])}}return new Uint8Array(e)},Mt=t=>{const e=yt(t),i=e.getUint8(9),r=e.getUint16(10,!0),s=e.getUint32(12,!0),n=e.getInt16(16,!0),o=e.getUint8(18);let a=null;return o&&(a=t.subarray(19,21+i)),{outputChannelCount:i,preSkip:r,inputSampleRate:s,outputGain:n,channelMappingFamily:o,channelMappingTable:a}};var tt;(function(t){t[t.STREAMINFO=0]="STREAMINFO",t[t.VORBIS_COMMENT=4]="VORBIS_COMMENT",t[t.PICTURE=6]="PICTURE"})(tt||(tt={}));const Ii=t=>{if(t.length<7||t[0]!==11||t[1]!==119)return null;const e=new z(t);e.skipBits(16),e.skipBits(16);const i=e.readBits(2);if(i===3)return null;const r=e.readBits(6),s=e.readBits(5);if(s>8)return null;const n=e.readBits(3),o=e.readBits(3);o&1&&o!==1&&e.skipBits(2),o&4&&e.skipBits(2),o===2&&e.skipBits(2);const a=e.readBits(1),l=Math.floor(r/2);return{fscod:i,bsid:s,bsmod:n,acmod:o,lfeon:a,bitRateCode:l}},Wi=[1,2,3,6],Ni=t=>{if(t.length<6||t[0]!==11||t[1]!==119)return null;const e=new z(t);e.skipBits(16);const i=e.readBits(2);if(e.skipBits(3),i!==0&&i!==2)return null;const r=e.readBits(11),s=e.readBits(2);let n=0,o;s===3?(n=e.readBits(2),o=3):o=e.readBits(2);const a=e.readBits(3),l=e.readBits(1),u=e.readBits(5);if(u<11||u>16)return null;const c=Wi[o];let p;return s<3?p=ki[s]/1e3:p=Si[n]/1e3,{dataRate:Math.round((r+1)*p/(c*16)),substreams:[{fscod:s,fscod2:n,bsid:u,bsmod:0,acmod:a,lfeon:l,numDepSub:0,chanLoc:0}]}};/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const it=[];/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const rt=new Uint8Array(0);class pe{constructor(e,i,r,s,n=-1,o,a){if(this.data=e,this.type=i,this.timestamp=r,this.duration=s,this.sequenceNumber=n,e===rt&&o===void 0)throw new Error("Internal error: byteLength must be explicitly provided when constructing metadata-only packets.");if(o===void 0&&(o=e.byteLength),!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(i!=="key"&&i!=="delta")throw new TypeError('type must be either "key" or "delta".');if(!Number.isFinite(r))throw new TypeError("timestamp must be a number.");if(!Number.isFinite(s)||s<0)throw new TypeError("duration must be a non-negative number.");if(!Number.isFinite(n))throw new TypeError("sequenceNumber must be a number.");if(!Number.isInteger(o)||o<0)throw new TypeError("byteLength must be a non-negative integer.");if(a!==void 0&&(typeof a!="object"||!a))throw new TypeError("sideData, when provided, must be an object.");if((a==null?void 0:a.alpha)!==void 0&&!(a.alpha instanceof Uint8Array))throw new TypeError("sideData.alpha, when provided, must be a Uint8Array.");if((a==null?void 0:a.alphaByteLength)!==void 0&&(!Number.isInteger(a.alphaByteLength)||a.alphaByteLength<0))throw new TypeError("sideData.alphaByteLength, when provided, must be a non-negative integer.");this.byteLength=o,this.sideData=a??{},this.sideData.alpha&&this.sideData.alphaByteLength===void 0&&(this.sideData.alphaByteLength=this.sideData.alpha.byteLength)}get isMetadataOnly(){return this.data===rt}get microsecondTimestamp(){return Math.trunc(Ge*this.timestamp)}get microsecondDuration(){return Math.trunc(Ge*this.duration)}toEncodedVideoChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");if(typeof EncodedVideoChunk>"u")throw new Error("Your browser does not support EncodedVideoChunk.");return new EncodedVideoChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}alphaToEncodedVideoChunk(e=this.type){if(!this.sideData.alpha)throw new TypeError("This packet does not contain alpha side data.");if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");if(typeof EncodedVideoChunk>"u")throw new Error("Your browser does not support EncodedVideoChunk.");return new EncodedVideoChunk({data:this.sideData.alpha,type:e,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}toEncodedAudioChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to an audio chunk.");if(typeof EncodedAudioChunk>"u")throw new Error("Your browser does not support EncodedAudioChunk.");return new EncodedAudioChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}static fromEncodedChunk(e,i){if(!(e instanceof EncodedVideoChunk||e instanceof EncodedAudioChunk))throw new TypeError("chunk must be an EncodedVideoChunk or EncodedAudioChunk.");const r=new Uint8Array(e.byteLength);return e.copyTo(r),new pe(r,e.type,e.timestamp/1e6,(e.duration??0)/1e6,void 0,void 0,i)}clone(e){if(e!==void 0&&(typeof e!="object"||e===null))throw new TypeError("options, when provided, must be an object.");if((e==null?void 0:e.data)!==void 0&&!(e.data instanceof Uint8Array))throw new TypeError("options.data, when provided, must be a Uint8Array.");if((e==null?void 0:e.type)!==void 0&&e.type!=="key"&&e.type!=="delta")throw new TypeError('options.type, when provided, must be either "key" or "delta".');if((e==null?void 0:e.timestamp)!==void 0&&!Number.isFinite(e.timestamp))throw new TypeError("options.timestamp, when provided, must be a number.");if((e==null?void 0:e.duration)!==void 0&&!Number.isFinite(e.duration))throw new TypeError("options.duration, when provided, must be a number.");if((e==null?void 0:e.sequenceNumber)!==void 0&&!Number.isFinite(e.sequenceNumber))throw new TypeError("options.sequenceNumber, when provided, must be a number.");if((e==null?void 0:e.sideData)!==void 0&&(typeof e.sideData!="object"||e.sideData===null))throw new TypeError("options.sideData, when provided, must be an object.");return new pe((e==null?void 0:e.data)??this.data,(e==null?void 0:e.type)??this.type,(e==null?void 0:e.timestamp)??this.timestamp,(e==null?void 0:e.duration)??this.duration,(e==null?void 0:e.sequenceNumber)??this.sequenceNumber,this.byteLength,(e==null?void 0:e.sideData)??this.sideData)}}/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Di=t=>{let i=(t.hasVideo?"video/":t.hasAudio?"audio/":"application/")+(t.isQuickTime?"quicktime":"mp4");if(t.codecStrings.length>0){const r=[...new Set(t.codecStrings)];i+=`; codecs="${r.join(", ")}"`}return i};/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const _e=8,st=16;/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Me{constructor(e){this.value=e}}class ze{constructor(e){this.value=e}}class zt{constructor(e){this.value=e}}class X{constructor(e){this.value=e}}var d;(function(t){t[t.EBML=440786851]="EBML",t[t.EBMLVersion=17030]="EBMLVersion",t[t.EBMLReadVersion=17143]="EBMLReadVersion",t[t.EBMLMaxIDLength=17138]="EBMLMaxIDLength",t[t.EBMLMaxSizeLength=17139]="EBMLMaxSizeLength",t[t.DocType=17026]="DocType",t[t.DocTypeVersion=17031]="DocTypeVersion",t[t.DocTypeReadVersion=17029]="DocTypeReadVersion",t[t.Void=236]="Void",t[t.Segment=408125543]="Segment",t[t.SeekHead=290298740]="SeekHead",t[t.Seek=19899]="Seek",t[t.SeekID=21419]="SeekID",t[t.SeekPosition=21420]="SeekPosition",t[t.Duration=17545]="Duration",t[t.Info=357149030]="Info",t[t.TimestampScale=2807729]="TimestampScale",t[t.MuxingApp=19840]="MuxingApp",t[t.WritingApp=22337]="WritingApp",t[t.Tracks=374648427]="Tracks",t[t.TrackEntry=174]="TrackEntry",t[t.TrackNumber=215]="TrackNumber",t[t.TrackUID=29637]="TrackUID",t[t.TrackType=131]="TrackType",t[t.FlagEnabled=185]="FlagEnabled",t[t.FlagDefault=136]="FlagDefault",t[t.FlagForced=21930]="FlagForced",t[t.FlagOriginal=21934]="FlagOriginal",t[t.FlagHearingImpaired=21931]="FlagHearingImpaired",t[t.FlagVisualImpaired=21932]="FlagVisualImpaired",t[t.FlagCommentary=21935]="FlagCommentary",t[t.FlagLacing=156]="FlagLacing",t[t.Name=21358]="Name",t[t.Language=2274716]="Language",t[t.LanguageBCP47=2274717]="LanguageBCP47",t[t.CodecID=134]="CodecID",t[t.CodecPrivate=25506]="CodecPrivate",t[t.CodecDelay=22186]="CodecDelay",t[t.SeekPreRoll=22203]="SeekPreRoll",t[t.DefaultDuration=2352003]="DefaultDuration",t[t.Video=224]="Video",t[t.PixelWidth=176]="PixelWidth",t[t.PixelHeight=186]="PixelHeight",t[t.AlphaMode=21440]="AlphaMode",t[t.Audio=225]="Audio",t[t.SamplingFrequency=181]="SamplingFrequency",t[t.Channels=159]="Channels",t[t.BitDepth=25188]="BitDepth",t[t.SimpleBlock=163]="SimpleBlock",t[t.BlockGroup=160]="BlockGroup",t[t.Block=161]="Block",t[t.BlockAdditions=30113]="BlockAdditions",t[t.BlockMore=166]="BlockMore",t[t.BlockAdditional=165]="BlockAdditional",t[t.BlockAddID=238]="BlockAddID",t[t.BlockDuration=155]="BlockDuration",t[t.ReferenceBlock=251]="ReferenceBlock",t[t.Cluster=524531317]="Cluster",t[t.Timestamp=231]="Timestamp",t[t.Cues=475249515]="Cues",t[t.CuePoint=187]="CuePoint",t[t.CueTime=179]="CueTime",t[t.CueTrackPositions=183]="CueTrackPositions",t[t.CueTrack=247]="CueTrack",t[t.CueClusterPosition=241]="CueClusterPosition",t[t.Colour=21936]="Colour",t[t.MatrixCoefficients=21937]="MatrixCoefficients",t[t.TransferCharacteristics=21946]="TransferCharacteristics",t[t.Primaries=21947]="Primaries",t[t.Range=21945]="Range",t[t.Projection=30320]="Projection",t[t.ProjectionType=30321]="ProjectionType",t[t.ProjectionPoseRoll=30325]="ProjectionPoseRoll",t[t.Attachments=423732329]="Attachments",t[t.AttachedFile=24999]="AttachedFile",t[t.FileDescription=18046]="FileDescription",t[t.FileName=18030]="FileName",t[t.FileMediaType=18016]="FileMediaType",t[t.FileData=18012]="FileData",t[t.FileUID=18094]="FileUID",t[t.Chapters=272869232]="Chapters",t[t.Tags=307544935]="Tags",t[t.Tag=29555]="Tag",t[t.Targets=25536]="Targets",t[t.TargetTypeValue=26826]="TargetTypeValue",t[t.TargetType=25546]="TargetType",t[t.TagTrackUID=25541]="TagTrackUID",t[t.TagEditionUID=25545]="TagEditionUID",t[t.TagChapterUID=25540]="TagChapterUID",t[t.TagAttachmentUID=25542]="TagAttachmentUID",t[t.SimpleTag=26568]="SimpleTag",t[t.TagName=17827]="TagName",t[t.TagLanguage=17530]="TagLanguage",t[t.TagString=17543]="TagString",t[t.TagBinary=17541]="TagBinary",t[t.ContentEncodings=28032]="ContentEncodings",t[t.ContentEncoding=25152]="ContentEncoding",t[t.ContentEncodingOrder=20529]="ContentEncodingOrder",t[t.ContentEncodingScope=20530]="ContentEncodingScope",t[t.ContentCompression=20532]="ContentCompression",t[t.ContentCompAlgo=16980]="ContentCompAlgo",t[t.ContentCompSettings=16981]="ContentCompSettings",t[t.ContentEncryption=20533]="ContentEncryption"})(d||(d={}));d.EBML,d.Segment;d.SeekHead,d.Info,d.Cluster,d.Tracks,d.Cues,d.Attachments,d.Chapters,d.Tags;const nt=t=>t<256?1:t<65536?2:t<1<<24?3:t<2**32?4:t<2**40?5:6,ot=t=>t<1n<<8n?1:t<1n<<16n?2:t<1n<<24n?3:t<1n<<32n?4:t<1n<<40n?5:t<1n<<48n?6:t<1n<<56n?7:8,at=t=>t>=-64&&t<64?1:t>=-8192&&t<8192?2:t>=-1048576&&t<1<<20?3:t>=-134217728&&t<1<<27?4:t>=-17179869184&&t<2**34?5:6,Hi=t=>{if(t<127)return 1;if(t<16383)return 2;if(t<(1<<21)-1)return 3;if(t<(1<<28)-1)return 4;if(t<2**35-1)return 5;if(t<2**42-1)return 6;throw new Error("EBML varint size not supported "+t)};class $i{constructor(e){this.writer=e,this.helper=new Uint8Array(8),this.helperView=new DataView(this.helper.buffer),this.offsets=new WeakMap,this.dataOffsets=new WeakMap}writeByte(e){this.helperView.setUint8(0,e),this.writer.write(this.helper.subarray(0,1))}writeFloat32(e){this.helperView.setFloat32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeFloat64(e){this.helperView.setFloat64(0,e,!1),this.writer.write(this.helper)}writeUnsignedInt(e,i=nt(e)){let r=0;switch(i){case 6:this.helperView.setUint8(r++,e/2**40|0);case 5:this.helperView.setUint8(r++,e/2**32|0);case 4:this.helperView.setUint8(r++,e>>24);case 3:this.helperView.setUint8(r++,e>>16);case 2:this.helperView.setUint8(r++,e>>8);case 1:this.helperView.setUint8(r++,e);break;default:throw new Error("Bad unsigned int size "+i)}this.writer.write(this.helper.subarray(0,r))}writeUnsignedBigInt(e,i=ot(e)){let r=0;for(let s=i-1;s>=0;s--)this.helperView.setUint8(r++,Number(e>>BigInt(s*8)&0xffn));this.writer.write(this.helper.subarray(0,r))}writeSignedInt(e,i=at(e)){e<0&&(e+=2**(i*8)),this.writeUnsignedInt(e,i)}writeVarInt(e,i=Hi(e)){let r=0;switch(i){case 1:this.helperView.setUint8(r++,128|e);break;case 2:this.helperView.setUint8(r++,64|e>>8),this.helperView.setUint8(r++,e);break;case 3:this.helperView.setUint8(r++,32|e>>16),this.helperView.setUint8(r++,e>>8),this.helperView.setUint8(r++,e);break;case 4:this.helperView.setUint8(r++,16|e>>24),this.helperView.setUint8(r++,e>>16),this.helperView.setUint8(r++,e>>8),this.helperView.setUint8(r++,e);break;case 5:this.helperView.setUint8(r++,8|e/2**32&7),this.helperView.setUint8(r++,e>>24),this.helperView.setUint8(r++,e>>16),this.helperView.setUint8(r++,e>>8),this.helperView.setUint8(r++,e);break;case 6:this.helperView.setUint8(r++,4|e/2**40&3),this.helperView.setUint8(r++,e/2**32|0),this.helperView.setUint8(r++,e>>24),this.helperView.setUint8(r++,e>>16),this.helperView.setUint8(r++,e>>8),this.helperView.setUint8(r++,e);break;default:throw new Error("Bad EBML varint size "+i)}this.writer.write(this.helper.subarray(0,r))}writeAsciiString(e){this.writer.write(new Uint8Array(e.split("").map(i=>i.charCodeAt(0))))}writeEBML(e){if(e!==null)if(e instanceof Uint8Array)this.writer.write(e);else if(Array.isArray(e))for(const i of e)this.writeEBML(i);else if(this.offsets.set(e,this.writer.getPos()),this.writeUnsignedInt(e.id),Array.isArray(e.data)){const i=this.writer.getPos(),r=e.size===-1?1:e.size??4;e.size===-1?this.writeByte(255):this.writer.seek(this.writer.getPos()+r);const s=this.writer.getPos();if(this.dataOffsets.set(e,s),this.writeEBML(e.data),e.size!==-1){const n=this.writer.getPos()-s,o=this.writer.getPos();this.writer.seek(i),this.writeVarInt(n,r),this.writer.seek(o)}}else if(typeof e.data=="number"){const i=e.size??nt(e.data);this.writeVarInt(i),this.writeUnsignedInt(e.data,i)}else if(typeof e.data=="bigint"){const i=e.size??ot(e.data);this.writeVarInt(i),this.writeUnsignedBigInt(e.data,i)}else if(typeof e.data=="string")this.writeVarInt(e.data.length),this.writeAsciiString(e.data);else if(e.data instanceof Uint8Array)this.writeVarInt(e.data.byteLength,e.size),this.writer.write(e.data);else if(e.data instanceof Me)this.writeVarInt(4),this.writeFloat32(e.data.value);else if(e.data instanceof ze)this.writeVarInt(8),this.writeFloat64(e.data.value);else if(e.data instanceof zt){const i=e.size??at(e.data.value);this.writeVarInt(i),this.writeSignedInt(e.data.value,i)}else if(e.data instanceof X){const i=E.encode(e.data.value);this.writeVarInt(i.length),this.writer.write(i)}else Ce(e.data)}}const ji={avc:"V_MPEG4/ISO/AVC",hevc:"V_MPEGH/ISO/HEVC",vp8:"V_VP8",vp9:"V_VP9",av1:"V_AV1",aac:"A_AAC",mp3:"A_MPEG/L3",opus:"A_OPUS",vorbis:"A_VORBIS",flac:"A_FLAC",ac3:"A_AC3",eac3:"A_EAC3","pcm-u8":"A_PCM/INT/LIT","pcm-s16":"A_PCM/INT/LIT","pcm-s16be":"A_PCM/INT/BIG","pcm-s24":"A_PCM/INT/LIT","pcm-s24be":"A_PCM/INT/BIG","pcm-s32":"A_PCM/INT/LIT","pcm-s32be":"A_PCM/INT/BIG","pcm-f32":"A_PCM/FLOAT/IEEE","pcm-f64":"A_PCM/FLOAT/IEEE",webvtt:"S_TEXT/WEBVTT"};/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const qi=t=>{let i=(t.hasVideo?"video/":t.hasAudio?"audio/":"application/")+(t.isWebM?"webm":"x-matroska");if(t.codecStrings.length>0){const r=[...new Set(t.codecStrings.filter(Boolean))];i+=`; codecs="${r.join(", ")}"`}return i};/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Ut=7,Vt=9,ge=t=>{const e=t.filePos,i=Li(t,9),r=new z(i);if(r.readBits(12)!==4095||(r.skipBits(1),r.readBits(2)!==0))return null;const o=r.readBits(1),a=r.readBits(2)+1,l=r.readBits(4);if(l===15)return null;r.skipBits(1);const u=r.readBits(3);if(u===0)throw new Error("ADTS frames with channel configuration 0 are not supported.");r.skipBits(1),r.skipBits(1),r.skipBits(1),r.skipBits(1);const c=r.readBits(13);r.skipBits(11);const p=r.readBits(2)+1;if(p!==1)throw new Error("ADTS frames with more than one AAC frame are not supported.");let b=null;return o===1?t.filePos-=2:b=r.readBits(16),{objectType:a,samplingFrequencyIndex:l,channelConfiguration:u,frameLength:c,numberOfAacFrames:p,crcCheck:b,startPos:e}};/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class te{constructor(e,i,r,s,n){this.bytes=e,this.view=i,this.offset=r,this.start=s,this.end=n,this.bufferPos=s-r}static tempFromBytes(e){return new te(e,yt(e),0,0,e.length)}get length(){return this.end-this.start}get filePos(){return this.offset+this.bufferPos}set filePos(e){this.bufferPos=e-this.offset}get remainingLength(){return Math.max(this.end-this.filePos,0)}skip(e){this.bufferPos+=e}slice(e,i=this.end-e){if(e<this.start||e+i>this.end)throw new RangeError("Slicing outside of original slice.");return new te(this.bytes,this.view,this.offset,e,e+i)}}const Qi=(t,e)=>{if(t.filePos<t.start||t.filePos+e>t.end)throw new RangeError(`Tried reading [${t.filePos}, ${t.filePos+e}), but slice is [${t.start}, ${t.end}). This is likely an internal error, please report it alongside the file that caused it.`)},Li=(t,e)=>{Qi(t,e);const i=t.bytes.subarray(t.bufferPos,t.bufferPos+e);return t.bufferPos+=e,i};/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Ot{constructor(e){this.mutex=new Ct,this.firstMediaStreamTimestamp=null,this.trackTimestampInfo=new WeakMap,this.output=e}onTrackClose(e){}validateAndNormalizeTimestamp(e,i,r){i+=e.source._timestampOffset;let s=this.trackTimestampInfo.get(e);if(!s){if(!r)throw new Error("First packet must be a key packet.");s={maxTimestamp:i,maxTimestampBeforeLastKeyPacket:i},this.trackTimestampInfo.set(e,s)}if(i<0)throw new Error(`Timestamps must be non-negative (got ${i}s).`);if(r&&(s.maxTimestampBeforeLastKeyPacket=s.maxTimestamp),i<s.maxTimestampBeforeLastKeyPacket)throw new Error(`Timestamps cannot be smaller than the largest timestamp of the previous GOP (a GOP begins with a key packet and ends right before the next key packet). Got ${i}s, but largest timestamp is ${s.maxTimestampBeforeLastKeyPacket}s.`);return s.maxTimestamp=Math.max(s.maxTimestamp,i),i}}/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const we=/<(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})>/g,Gi=/(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})/,Ki=t=>{const e=Gi.exec(t);if(!e)throw new Error("Expected match.");return 60*60*1e3*Number(e[1]||"0")+60*1e3*Number(e[2])+1e3*Number(e[3])+Number(e[4])},Rt=t=>{const e=Math.floor(t/36e5),i=Math.floor(t%(60*60*1e3)/(60*1e3)),r=Math.floor(t%(60*1e3)/1e3),s=t%1e3;return e.toString().padStart(2,"0")+":"+i.toString().padStart(2,"0")+":"+r.toString().padStart(2,"0")+"."+s.toString().padStart(3,"0")};/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class ct{constructor(e){this.writer=e,this.helper=new Uint8Array(8),this.helperView=new DataView(this.helper.buffer),this.offsets=new WeakMap}writeU32(e){this.helperView.setUint32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeU64(e){this.helperView.setUint32(0,Math.floor(e/2**32),!1),this.helperView.setUint32(4,e,!1),this.writer.write(this.helper.subarray(0,8))}writeAscii(e){for(let i=0;i<e.length;i++)this.helperView.setUint8(i%8,e.charCodeAt(i)),i%8===7&&this.writer.write(this.helper);e.length%8!==0&&this.writer.write(this.helper.subarray(0,e.length%8))}writeBox(e){if(this.offsets.set(e,this.writer.getPos()),e.contents&&!e.children)this.writeBoxHeader(e,e.size??e.contents.byteLength+8),this.writer.write(e.contents);else{const i=this.writer.getPos();if(this.writeBoxHeader(e,0),e.contents&&this.writer.write(e.contents),e.children)for(const n of e.children)n&&this.writeBox(n);const r=this.writer.getPos(),s=e.size??r-i;this.writer.seek(i),this.writeBoxHeader(e,s),this.writer.seek(r)}}writeBoxHeader(e,i){this.writeU32(e.largeSize?1:i),this.writeAscii(e.type),e.largeSize&&this.writeU64(i)}measureBoxHeader(e){return 8+(e.largeSize?8:0)}patchBox(e){const i=this.offsets.get(e);m(i!==void 0);const r=this.writer.getPos();this.writer.seek(i),this.writeBox(e),this.writer.seek(r)}measureBox(e){if(e.contents&&!e.children)return this.measureBoxHeader(e)+e.contents.byteLength;{let i=this.measureBoxHeader(e);if(e.contents&&(i+=e.contents.byteLength),e.children)for(const r of e.children)r&&(i+=this.measureBox(r));return i}}}const C=new Uint8Array(8),D=new DataView(C.buffer),_=t=>[(t%256+256)%256],g=t=>(D.setUint16(0,t,!1),[C[0],C[1]]),It=t=>(D.setInt16(0,t,!1),[C[0],C[1]]),Wt=t=>(D.setUint32(0,t,!1),[C[1],C[2],C[3]]),f=t=>(D.setUint32(0,t,!1),[C[0],C[1],C[2],C[3]]),Y=t=>(D.setInt32(0,t,!1),[C[0],C[1],C[2],C[3]]),ie=t=>(D.setUint32(0,Math.floor(t/2**32),!1),D.setUint32(4,t,!1),[C[0],C[1],C[2],C[3],C[4],C[5],C[6],C[7]]),Nt=t=>(D.setInt16(0,2**8*t,!1),[C[0],C[1]]),j=t=>(D.setInt32(0,2**16*t,!1),[C[0],C[1],C[2],C[3]]),ve=t=>(D.setInt32(0,2**30*t,!1),[C[0],C[1],C[2],C[3]]),Pe=(t,e)=>{const i=[];let r=t;do{let s=r&127;r>>=7,i.length>0&&(s|=128),i.push(s)}while(r>0||e);return i.reverse()},A=(t,e=!1)=>{const i=Array(t.length).fill(null).map((r,s)=>t.charCodeAt(s));return e&&i.push(0),i},De=t=>{let e=null;for(const i of t)(!e||i.timestamp>e.timestamp)&&(e=i);return e},Dt=t=>{const e=t*(Math.PI/180),i=Math.round(Math.cos(e)),r=Math.round(Math.sin(e));return[i,r,0,-r,i,0,0,0,1]},Ht=Dt(0),$t=t=>[j(t[0]),j(t[1]),ve(t[2]),j(t[3]),j(t[4]),ve(t[5]),j(t[6]),j(t[7]),ve(t[8])],w=(t,e,i)=>({type:t,contents:e&&new Uint8Array(e.flat(10)),children:i}),k=(t,e,i,r,s)=>w(t,[_(e),Wt(i),r??[]],s),Xi=t=>t.isQuickTime?w("ftyp",[A("qt  "),f(512),A("qt  ")]):t.fragmented?w("ftyp",[A("iso5"),f(512),A("iso5"),A("iso6"),A("mp41")]):w("ftyp",[A("isom"),f(512),A("isom"),t.holdsAvc?A("avc1"):[],A("mp41")]),he=t=>({type:"mdat",largeSize:t}),Yi=t=>({type:"free",size:t}),le=t=>w("moov",void 0,[Zi(t.creationTime,t.trackDatas),...t.trackDatas.map(e=>Ji(e,t.creationTime)),t.isFragmented?Or(t.trackDatas):null,Kr(t)]),Zi=(t,e)=>{const i=P(Math.max(0,...e.filter(o=>o.samples.length>0).map(o=>{const a=De(o.samples);return a.timestamp+a.duration})),Ue),r=Math.max(0,...e.map(o=>o.track.id))+1,s=!re(t)||!re(i),n=s?ie:f;return k("mvhd",+s,0,[n(t),n(t),f(Ue),n(i),j(1),Nt(1),Array(10).fill(0),$t(Ht),Array(24).fill(0),f(r)])},Ji=(t,e)=>{const i=ls(t);return w("trak",void 0,[er(t,e),tr(t,e),i.name!==void 0?w("udta",void 0,[w("name",[...E.encode(i.name)])]):null])},er=(t,e)=>{var l;const i=De(t.samples),r=P(i?i.timestamp+i.duration:0,Ue),s=!re(e)||!re(r),n=s?ie:f;let o;if(t.type==="video"){const u=t.track.metadata.rotation;o=Dt(u??0)}else o=Ht;let a=2;return((l=t.track.metadata.disposition)==null?void 0:l.default)!==!1&&(a|=1),k("tkhd",+s,a,[n(e),n(e),f(t.track.id),f(0),n(r),Array(8).fill(0),g(0),g(t.track.id),Nt(t.type==="audio"?1:0),g(0),$t(o),j(t.type==="video"?t.info.width:0),j(t.type==="video"?t.info.height:0)])},tr=(t,e)=>w("mdia",void 0,[ir(t,e),He(!0,rr[t.type],sr[t.type]),nr(t)]),ir=(t,e)=>{const i=De(t.samples),r=P(i?i.timestamp+i.duration:0,t.timescale),s=!re(e)||!re(r),n=s?ie:f;return k("mdhd",+s,0,[n(e),n(e),f(t.timescale),n(r),g(Lt(t.track.metadata.languageCode??St)),g(0)])},rr={video:"vide",audio:"soun",subtitle:"text"},sr={video:"MediabunnyVideoHandler",audio:"MediabunnySoundHandler",subtitle:"MediabunnyTextHandler"},He=(t,e,i,r="\0\0\0\0")=>k("hdlr",0,0,[t?A("mhlr"):f(0),A(e),A(r),f(0),f(0),A(i,!0)]),nr=t=>w("minf",void 0,[lr[t.type](),ur(),hr(t)]),or=()=>k("vmhd",0,1,[g(0),g(0),g(0),g(0)]),ar=()=>k("smhd",0,0,[g(0),g(0)]),cr=()=>k("nmhd",0,0),lr={video:or,audio:ar,subtitle:cr},ur=()=>w("dinf",void 0,[dr()]),dr=()=>k("dref",0,0,[f(1)],[fr()]),fr=()=>k("url ",0,1),hr=t=>{const e=t.compositionTimeOffsetTable.length>1||t.compositionTimeOffsetTable.some(i=>i.sampleCompositionTimeOffset!==0);return w("stbl",void 0,[mr(t),Er(t),e?Ur(t):null,e?Vr(t):null,Fr(t),Mr(t),zr(t),Br(t)])},mr=t=>{let e;if(t.type==="video")e=pr(Jr(t.track.source._codec,t.info.decoderConfig.codec),t);else if(t.type==="audio"){const i=Qt(t.track.source._codec,t.muxer.isQuickTime);m(i),e=Tr(i,t)}else t.type==="subtitle"&&(e=Pr(is[t.track.source._codec],t));return m(e),k("stsd",0,0,[f(1)],[e])},pr=(t,e)=>w(t,[Array(6).fill(0),g(1),g(0),g(0),Array(12).fill(0),g(e.info.width),g(e.info.height),f(4718592),f(4718592),f(0),g(1),Array(32).fill(0),g(24),It(65535)],[es[e.track.source._codec](e),bt(e.info.decoderConfig.colorSpace)?gr(e):null]),gr=t=>w("colr",[A("nclx"),g(ye[t.info.decoderConfig.colorSpace.primaries]),g(be[t.info.decoderConfig.colorSpace.transfer]),g(Te[t.info.decoderConfig.colorSpace.matrix]),_((t.info.decoderConfig.colorSpace.fullRange?1:0)<<7)]),wr=t=>t.info.decoderConfig&&w("avcC",[...Z(t.info.decoderConfig.description)]),yr=t=>t.info.decoderConfig&&w("hvcC",[...Z(t.info.decoderConfig.description)]),lt=t=>{var b,y,T,S;if(!t.info.decoderConfig)return null;const e=t.info.decoderConfig,i=e.codec.split("."),r=Number(i[1]),s=Number(i[2]),n=Number(i[3]),o=i[4]?Number(i[4]):1,a=i[8]?Number(i[8]):Number(((b=e.colorSpace)==null?void 0:b.fullRange)??0),l=(n<<4)+(o<<1)+a,u=i[5]?Number(i[5]):(y=e.colorSpace)!=null&&y.primaries?ye[e.colorSpace.primaries]:2,c=i[6]?Number(i[6]):(T=e.colorSpace)!=null&&T.transfer?be[e.colorSpace.transfer]:2,p=i[7]?Number(i[7]):(S=e.colorSpace)!=null&&S.matrix?Te[e.colorSpace.matrix]:2;return k("vpcC",1,0,[_(r),_(s),_(l),_(u),_(c),_(p),g(0)])},br=t=>w("av1C",vt(t.info.decoderConfig.codec)),Tr=(t,e)=>{var n;let i=0,r,s=16;if(Q.includes(e.track.source._codec)){const o=e.track.source._codec,{sampleSize:a}=ne(o);s=8*a,s>16&&(i=1)}return i===0?r=[Array(6).fill(0),g(1),g(i),g(0),f(0),g(e.info.numberOfChannels),g(s),g(0),g(0),g(e.info.sampleRate<2**16?e.info.sampleRate:0),g(0)]:r=[Array(6).fill(0),g(1),g(i),g(0),f(0),g(e.info.numberOfChannels),g(Math.min(s,16)),g(0),g(0),g(e.info.sampleRate<2**16?e.info.sampleRate:0),g(0),f(1),f(s/8),f(e.info.numberOfChannels*s/8),f(2)],w(t,r,[((n=ts(e.track.source._codec,e.muxer.isQuickTime))==null?void 0:n(e))??null])},Ae=t=>{let e;switch(t.track.source._codec){case"aac":e=64;break;case"mp3":e=107;break;case"vorbis":e=221;break;default:throw new Error(`Unhandled audio codec: ${t.track.source._codec}`)}let i=[..._(e),..._(21),...Wt(0),...f(0),...f(0)];if(t.info.decoderConfig.description){const r=Z(t.info.decoderConfig.description);i=[...i,..._(5),...Pe(r.byteLength),...r]}return i=[...g(1),..._(0),..._(4),...Pe(i.length),...i,..._(6),..._(1),..._(2)],i=[..._(3),...Pe(i.length),...i],k("esds",0,0,i)},K=t=>w("wave",void 0,[Cr(t),kr(t),w("\0\0\0\0")]),Cr=t=>w("frma",[A(Qt(t.track.source._codec,t.muxer.isQuickTime))]),kr=t=>{const{littleEndian:e}=ne(t.track.source._codec);return w("enda",[g(+e)])},Sr=t=>{var l;let e=t.info.numberOfChannels,i=3840,r=t.info.sampleRate,s=0,n=0,o=new Uint8Array(0);const a=(l=t.info.decoderConfig)==null?void 0:l.description;if(a){m(a.byteLength>=18);const u=Z(a),c=Mt(u);e=c.outputChannelCount,i=c.preSkip,r=c.inputSampleRate,s=c.outputGain,n=c.channelMappingFamily,c.channelMappingTable&&(o=c.channelMappingTable)}return w("dOps",[_(0),_(e),g(i),f(r),It(s),_(n),...o])},xr=t=>{var r;const e=(r=t.info.decoderConfig)==null?void 0:r.description;m(e);const i=Z(e);return k("dfLa",0,0,[...i.subarray(4)])},I=t=>{const{littleEndian:e,sampleSize:i}=ne(t.track.source._codec),r=+e;return k("pcmC",0,0,[_(r),_(8*i)])},_r=t=>{const e=Ii(t.info.firstPacket.data);if(!e)throw new Error("Couldn't extract AC-3 frame info from the audio packet. Ensure the packets contain valid AC-3 sync frames (as specified in ETSI TS 102 366).");const i=new Uint8Array(3),r=new z(i);return r.writeBits(2,e.fscod),r.writeBits(5,e.bsid),r.writeBits(3,e.bsmod),r.writeBits(3,e.acmod),r.writeBits(1,e.lfeon),r.writeBits(5,e.bitRateCode),r.writeBits(5,0),w("dac3",[...i])},vr=t=>{const e=Ni(t.info.firstPacket.data);if(!e)throw new Error("Couldn't extract E-AC-3 frame info from the audio packet. Ensure the packets contain valid E-AC-3 sync frames (as specified in ETSI TS 102 366).");let i=16;for(const o of e.substreams)i+=23,o.numDepSub>0?i+=9:i+=1;const r=Math.ceil(i/8),s=new Uint8Array(r),n=new z(s);n.writeBits(13,e.dataRate),n.writeBits(3,e.substreams.length-1);for(const o of e.substreams)n.writeBits(2,o.fscod),n.writeBits(5,o.bsid),n.writeBits(1,0),n.writeBits(1,0),n.writeBits(3,o.bsmod),n.writeBits(3,o.acmod),n.writeBits(1,o.lfeon),n.writeBits(3,0),n.writeBits(4,o.numDepSub),o.numDepSub>0?n.writeBits(9,o.chanLoc):n.writeBits(1,0);return w("dec3",[...s])},Pr=(t,e)=>w(t,[Array(6).fill(0),g(1)],[rs[e.track.source._codec](e)]),Ar=t=>w("vttC",[...E.encode(t.info.config.description)]),Er=t=>k("stts",0,0,[f(t.timeToSampleTable.length),t.timeToSampleTable.map(e=>[f(e.sampleCount),f(e.sampleDelta)])]),Br=t=>{if(t.samples.every(i=>i.type==="key"))return null;const e=[...t.samples.entries()].filter(([,i])=>i.type==="key");return k("stss",0,0,[f(e.length),e.map(([i])=>f(i+1))])},Fr=t=>k("stsc",0,0,[f(t.compactlyCodedChunkTable.length),t.compactlyCodedChunkTable.map(e=>[f(e.firstChunk),f(e.samplesPerChunk),f(1)])]),Mr=t=>{if(t.type==="audio"&&t.info.requiresPcmTransformation){const{sampleSize:e}=ne(t.track.source._codec);return k("stsz",0,0,[f(e*t.info.numberOfChannels),f(t.samples.reduce((i,r)=>i+P(r.duration,t.timescale),0))])}return k("stsz",0,0,[f(0),f(t.samples.length),t.samples.map(e=>f(e.size))])},zr=t=>t.finalizedChunks.length>0&&V(t.finalizedChunks).offset>=2**32?k("co64",0,0,[f(t.finalizedChunks.length),t.finalizedChunks.map(e=>ie(e.offset))]):k("stco",0,0,[f(t.finalizedChunks.length),t.finalizedChunks.map(e=>f(e.offset))]),Ur=t=>k("ctts",1,0,[f(t.compositionTimeOffsetTable.length),t.compositionTimeOffsetTable.map(e=>[f(e.sampleCount),Y(e.sampleCompositionTimeOffset)])]),Vr=t=>{let e=1/0,i=-1/0,r=1/0,s=-1/0;m(t.compositionTimeOffsetTable.length>0),m(t.samples.length>0);for(let o=0;o<t.compositionTimeOffsetTable.length;o++){const a=t.compositionTimeOffsetTable[o];e=Math.min(e,a.sampleCompositionTimeOffset),i=Math.max(i,a.sampleCompositionTimeOffset)}for(let o=0;o<t.samples.length;o++){const a=t.samples[o];r=Math.min(r,P(a.timestamp,t.timescale)),s=Math.max(s,P(a.timestamp+a.duration,t.timescale))}const n=Math.max(-e,0);return s>=2**31?null:k("cslg",0,0,[Y(n),Y(e),Y(i),Y(r),Y(s)])},Or=t=>w("mvex",void 0,t.map(Rr)),Rr=t=>k("trex",0,0,[f(t.track.id),f(1),f(0),f(0),f(0)]),ut=(t,e)=>w("moof",void 0,[Ir(t),...e.map(Wr)]),Ir=t=>k("mfhd",0,0,[f(t)]),jt=t=>{let e=0,i=0;const r=0,s=0,n=t.type==="delta";return i|=+n,n?e|=1:e|=2,e<<24|i<<16|r<<8|s},Wr=t=>w("traf",void 0,[Nr(t),Dr(t),Hr(t)]),Nr=t=>{m(t.currentChunk);let e=0;e|=8,e|=16,e|=32,e|=131072;const i=t.currentChunk.samples[1]??t.currentChunk.samples[0],r={duration:i.timescaleUnitsToNextSample,size:i.size,flags:jt(i)};return k("tfhd",0,e,[f(t.track.id),f(r.duration),f(r.size),f(r.flags)])},Dr=t=>(m(t.currentChunk),k("tfdt",1,0,[ie(P(t.currentChunk.startTimestamp,t.timescale))])),Hr=t=>{m(t.currentChunk);const e=t.currentChunk.samples.map(S=>S.timescaleUnitsToNextSample),i=t.currentChunk.samples.map(S=>S.size),r=t.currentChunk.samples.map(jt),s=t.currentChunk.samples.map(S=>P(S.timestamp-S.decodeTimestamp,t.timescale)),n=new Set(e),o=new Set(i),a=new Set(r),l=new Set(s),u=a.size===2&&r[0]!==r[1],c=n.size>1,p=o.size>1,b=!u&&a.size>1,y=l.size>1||[...l].some(S=>S!==0);let T=0;return T|=1,T|=4*+u,T|=256*+c,T|=512*+p,T|=1024*+b,T|=2048*+y,k("trun",1,T,[f(t.currentChunk.samples.length),f(t.currentChunk.offset-t.currentChunk.moofOffset||0),u?f(r[0]):[],t.currentChunk.samples.map((S,B)=>[c?f(e[B]):[],p?f(i[B]):[],b?f(r[B]):[],y?Y(s[B]):[]])])},$r=t=>w("mfra",void 0,[...t.map(jr),qr()]),jr=(t,e)=>k("tfra",1,0,[f(t.track.id),f(63),f(t.finalizedChunks.length),t.finalizedChunks.map(r=>[ie(P(r.samples[0].timestamp,t.timescale)),ie(r.moofOffset),f(e+1),f(1),f(1)])]),qr=()=>k("mfro",0,0,[f(0)]),Qr=()=>w("vtte"),Lr=(t,e,i,r,s)=>w("vttc",void 0,[s!==null?w("vsid",[Y(s)]):null,i!==null?w("iden",[...E.encode(i)]):null,e!==null?w("ctim",[...E.encode(Rt(e))]):null,r!==null?w("sttg",[...E.encode(r)]):null,w("payl",[...E.encode(t)])]),Gr=t=>w("vtta",[...E.encode(t)]),Kr=t=>{const e=[],i=t.format._options.metadataFormat??"auto",r=t.output._metadataTags;if(i==="mdir"||i==="auto"&&!t.isQuickTime){const s=Yr(r);s&&e.push(s)}else if(i==="mdta"){const s=Zr(r);s&&e.push(s)}else(i==="udta"||i==="auto"&&t.isQuickTime)&&Xr(e,t.output._metadataTags);return e.length===0?null:w("udta",void 0,e)},Xr=(t,e)=>{for(const{key:i,value:r}of Ve(e))switch(i){case"title":t.push(W("nam",r));break;case"description":t.push(W("des",r));break;case"artist":t.push(W("ART",r));break;case"album":t.push(W("alb",r));break;case"albumArtist":t.push(W("albr",r));break;case"genre":t.push(W("gen",r));break;case"date":t.push(W("day",r.toISOString().slice(0,10)));break;case"comment":t.push(W("cmt",r));break;case"lyrics":t.push(W("lyr",r));break;case"raw":break;case"discNumber":case"discsTotal":case"trackNumber":case"tracksTotal":case"images":break;default:Ce(i)}if(e.raw)for(const i in e.raw){const r=e.raw[i];r==null||i.length!==4||t.some(s=>s.type===i)||(typeof r=="string"?t.push(W(i,r)):r instanceof Uint8Array&&t.push(w(i,Array.from(r))))}},W=(t,e)=>{const i=E.encode(e);return w(t,[g(i.length),g(Lt("und")),Array.from(i)])},dt={"image/jpeg":13,"image/png":14,"image/bmp":27},qt=(t,e)=>{const i=[];for(const{key:r,value:s}of Ve(t))switch(r){case"title":i.push({key:e?"title":"nam",value:U(s)});break;case"description":i.push({key:e?"description":"des",value:U(s)});break;case"artist":i.push({key:e?"artist":"ART",value:U(s)});break;case"album":i.push({key:e?"album":"alb",value:U(s)});break;case"albumArtist":i.push({key:e?"album_artist":"aART",value:U(s)});break;case"comment":i.push({key:e?"comment":"cmt",value:U(s)});break;case"genre":i.push({key:e?"genre":"gen",value:U(s)});break;case"lyrics":i.push({key:e?"lyrics":"lyr",value:U(s)});break;case"date":i.push({key:e?"date":"day",value:U(s.toISOString().slice(0,10))});break;case"images":for(const n of s)n.kind==="coverFront"&&i.push({key:"covr",value:w("data",[f(dt[n.mimeType]??0),f(0),Array.from(n.data)])});break;case"trackNumber":if(e){const n=t.tracksTotal!==void 0?`${s}/${t.tracksTotal}`:s.toString();i.push({key:"track",value:U(n)})}else i.push({key:"trkn",value:w("data",[f(0),f(0),g(0),g(s),g(t.tracksTotal??0),g(0)])});break;case"discNumber":e||i.push({key:"disc",value:w("data",[f(0),f(0),g(0),g(s),g(t.discsTotal??0),g(0)])});break;case"tracksTotal":case"discsTotal":break;case"raw":break;default:Ce(r)}if(t.raw)for(const r in t.raw){const s=t.raw[r];s==null||!e&&r.length!==4||i.some(n=>n.key===r)||(typeof s=="string"?i.push({key:r,value:U(s)}):s instanceof Uint8Array?i.push({key:r,value:w("data",[f(0),f(0),Array.from(s)])}):s instanceof xt&&i.push({key:r,value:w("data",[f(dt[s.mimeType]??0),f(0),Array.from(s.data)])}))}return i},Yr=t=>{const e=qt(t,!1);return e.length===0?null:k("meta",0,0,void 0,[He(!1,"mdir","","appl"),w("ilst",void 0,e.map(i=>w(i.key,void 0,[i.value])))])},Zr=t=>{const e=qt(t,!0);return e.length===0?null:w("meta",void 0,[He(!1,"mdta",""),k("keys",0,0,[f(e.length)],e.map(i=>w("mdta",[...E.encode(i.key)]))),w("ilst",void 0,e.map((i,r)=>{const s=String.fromCharCode(...f(r+1));return w(s,void 0,[i.value])}))])},U=t=>w("data",[f(1),f(0),...E.encode(t)]),Jr=(t,e)=>{switch(t){case"avc":return e.startsWith("avc3")?"avc3":"avc1";case"hevc":return"hvc1";case"vp8":return"vp08";case"vp9":return"vp09";case"av1":return"av01"}},es={avc:wr,hevc:yr,vp8:lt,vp9:lt,av1:br},Qt=(t,e)=>{switch(t){case"aac":return"mp4a";case"mp3":return"mp4a";case"opus":return"Opus";case"vorbis":return"mp4a";case"flac":return"fLaC";case"ulaw":return"ulaw";case"alaw":return"alaw";case"pcm-u8":return"raw ";case"pcm-s8":return"sowt";case"ac3":return"ac-3";case"eac3":return"ec-3"}if(e)switch(t){case"pcm-s16":return"sowt";case"pcm-s16be":return"twos";case"pcm-s24":return"in24";case"pcm-s24be":return"in24";case"pcm-s32":return"in32";case"pcm-s32be":return"in32";case"pcm-f32":return"fl32";case"pcm-f32be":return"fl32";case"pcm-f64":return"fl64";case"pcm-f64be":return"fl64"}else switch(t){case"pcm-s16":return"ipcm";case"pcm-s16be":return"ipcm";case"pcm-s24":return"ipcm";case"pcm-s24be":return"ipcm";case"pcm-s32":return"ipcm";case"pcm-s32be":return"ipcm";case"pcm-f32":return"fpcm";case"pcm-f32be":return"fpcm";case"pcm-f64":return"fpcm";case"pcm-f64be":return"fpcm"}},ts=(t,e)=>{switch(t){case"aac":return Ae;case"mp3":return Ae;case"opus":return Sr;case"vorbis":return Ae;case"flac":return xr;case"ac3":return _r;case"eac3":return vr}if(e)switch(t){case"pcm-s24":return K;case"pcm-s24be":return K;case"pcm-s32":return K;case"pcm-s32be":return K;case"pcm-f32":return K;case"pcm-f32be":return K;case"pcm-f64":return K;case"pcm-f64be":return K}else switch(t){case"pcm-s16":return I;case"pcm-s16be":return I;case"pcm-s24":return I;case"pcm-s24be":return I;case"pcm-s32":return I;case"pcm-s32be":return I;case"pcm-f32":return I;case"pcm-f32be":return I;case"pcm-f64":return I;case"pcm-f64be":return I}return null},is={webvtt:"wvtt"},rs={webvtt:Ar},Lt=t=>{m(t.length===3);let e=0;for(let i=0;i<3;i++)e<<=5,e+=t.charCodeAt(i)-96;return e};/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Gt{constructor(){this.ensureMonotonicity=!1,this.trackedWrites=null,this.trackedStart=-1,this.trackedEnd=-1}start(){}maybeTrackWrites(e){if(!this.trackedWrites)return;let i=this.getPos();if(i<this.trackedStart){if(i+e.byteLength<=this.trackedStart)return;e=e.subarray(this.trackedStart-i),i=0}const r=i+e.byteLength-this.trackedStart;let s=this.trackedWrites.byteLength;for(;s<r;)s*=2;if(s!==this.trackedWrites.byteLength){const n=new Uint8Array(s);n.set(this.trackedWrites,0),this.trackedWrites=n}this.trackedWrites.set(e,i-this.trackedStart),this.trackedEnd=Math.max(this.trackedEnd,i+e.byteLength)}startTrackingWrites(){this.trackedWrites=new Uint8Array(2**10),this.trackedStart=this.getPos(),this.trackedEnd=this.trackedStart}stopTrackingWrites(){if(!this.trackedWrites)throw new Error("Internal error: Can't get tracked writes since nothing was tracked.");const i={data:this.trackedWrites.subarray(0,this.trackedEnd-this.trackedStart),start:this.trackedStart,end:this.trackedEnd};return this.trackedWrites=null,i}}const Ee=2**16,Be=2**32;class Kt extends Gt{constructor(e){if(super(),this.pos=0,this.maxPos=0,this.target=e,this.supportsResize="resize"in new ArrayBuffer(0),this.supportsResize)try{this.buffer=new ArrayBuffer(Ee,{maxByteLength:Be})}catch{this.buffer=new ArrayBuffer(Ee),this.supportsResize=!1}else this.buffer=new ArrayBuffer(Ee);this.bytes=new Uint8Array(this.buffer)}ensureSize(e){let i=this.buffer.byteLength;for(;i<e;)i*=2;if(i!==this.buffer.byteLength){if(i>Be)throw new Error(`ArrayBuffer exceeded maximum size of ${Be} bytes. Please consider using another target.`);if(this.supportsResize)this.buffer.resize(i);else{const r=new ArrayBuffer(i),s=new Uint8Array(r);s.set(this.bytes,0),this.buffer=r,this.bytes=s}}}write(e){var i,r;this.maybeTrackWrites(e),this.ensureSize(this.pos+e.byteLength),this.bytes.set(e,this.pos),(r=(i=this.target).onwrite)==null||r.call(i,this.pos,this.pos+e.byteLength),this.pos+=e.byteLength,this.maxPos=Math.max(this.maxPos,this.pos)}seek(e){this.pos=e}getPos(){return this.pos}async flush(){}async finalize(){this.ensureSize(this.pos),this.target.buffer=this.buffer.slice(0,Math.max(this.maxPos,this.pos))}async close(){}getSlice(e,i){return this.bytes.slice(e,i)}}const ss=2**24,ns=2;class os extends Gt{constructor(e){super(),this.pos=0,this.sections=[],this.lastWriteEnd=0,this.lastFlushEnd=0,this.writer=null,this.chunks=[],this.target=e,this.chunked=e._options.chunked??!1,this.chunkSize=e._options.chunkSize??ss}start(){this.writer=this.target._writable.getWriter()}write(e){var i,r;if(this.pos>this.lastWriteEnd){const s=this.pos-this.lastWriteEnd;this.pos=this.lastWriteEnd,this.write(new Uint8Array(s))}this.maybeTrackWrites(e),this.sections.push({data:e.slice(),start:this.pos}),(r=(i=this.target).onwrite)==null||r.call(i,this.pos,this.pos+e.byteLength),this.pos+=e.byteLength,this.lastWriteEnd=Math.max(this.lastWriteEnd,this.pos)}seek(e){this.pos=e}getPos(){return this.pos}async flush(){if(this.pos>this.lastWriteEnd){const r=this.pos-this.lastWriteEnd;this.pos=this.lastWriteEnd,this.write(new Uint8Array(r))}if(m(this.writer),this.sections.length===0)return;const e=[],i=[...this.sections].sort((r,s)=>r.start-s.start);e.push({start:i[0].start,size:i[0].data.byteLength});for(let r=1;r<i.length;r++){const s=e[e.length-1],n=i[r];n.start<=s.start+s.size?s.size=Math.max(s.size,n.start+n.data.byteLength-s.start):e.push({start:n.start,size:n.data.byteLength})}for(const r of e){r.data=new Uint8Array(r.size);for(const s of this.sections)r.start<=s.start&&s.start<r.start+r.size&&r.data.set(s.data,s.start-r.start);if(this.writer.desiredSize!==null&&this.writer.desiredSize<=0&&await this.writer.ready,this.chunked)this.writeDataIntoChunks(r.data,r.start),this.tryToFlushChunks();else{if(this.ensureMonotonicity&&r.start!==this.lastFlushEnd)throw new Error("Internal error: Monotonicity violation.");this.writer.write({type:"write",data:r.data,position:r.start}),this.lastFlushEnd=r.start+r.data.byteLength}}this.sections.length=0}writeDataIntoChunks(e,i){let r=this.chunks.findIndex(l=>l.start<=i&&i<l.start+this.chunkSize);r===-1&&(r=this.createChunk(i));const s=this.chunks[r],n=i-s.start,o=e.subarray(0,Math.min(this.chunkSize-n,e.byteLength));s.data.set(o,n);const a={start:n,end:n+o.byteLength};if(this.insertSectionIntoChunk(s,a),s.written[0].start===0&&s.written[0].end===this.chunkSize&&(s.shouldFlush=!0),this.chunks.length>ns){for(let l=0;l<this.chunks.length-1;l++)this.chunks[l].shouldFlush=!0;this.tryToFlushChunks()}o.byteLength<e.byteLength&&this.writeDataIntoChunks(e.subarray(o.byteLength),i+o.byteLength)}insertSectionIntoChunk(e,i){let r=0,s=e.written.length-1,n=-1;for(;r<=s;){const o=Math.floor(r+(s-r+1)/2);e.written[o].start<=i.start?(r=o+1,n=o):s=o-1}for(e.written.splice(n+1,0,i),(n===-1||e.written[n].end<i.start)&&n++;n<e.written.length-1&&e.written[n].end>=e.written[n+1].start;)e.written[n].end=Math.max(e.written[n].end,e.written[n+1].end),e.written.splice(n+1,1)}createChunk(e){const r={start:Math.floor(e/this.chunkSize)*this.chunkSize,data:new Uint8Array(this.chunkSize),written:[],shouldFlush:!1};return this.chunks.push(r),this.chunks.sort((s,n)=>s.start-n.start),this.chunks.indexOf(r)}tryToFlushChunks(e=!1){m(this.writer);for(let i=0;i<this.chunks.length;i++){const r=this.chunks[i];if(!(!r.shouldFlush&&!e)){for(const s of r.written){const n=r.start+s.start;if(this.ensureMonotonicity&&n!==this.lastFlushEnd)throw new Error("Internal error: Monotonicity violation.");this.writer.write({type:"write",data:r.data.subarray(s.start,s.end),position:n}),this.lastFlushEnd=r.start+s.end}this.chunks.splice(i--,1)}}}finalize(){return this.chunked&&this.tryToFlushChunks(!0),m(this.writer),this.writer.close()}async close(){var e;return(e=this.writer)==null?void 0:e.close()}}/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class $e{constructor(){this._output=null,this.onwrite=null}}class as extends $e{constructor(){super(...arguments),this.buffer=null}_createWriter(){return new Kt(this)}}class Ts extends $e{constructor(e,i={}){if(super(),!(e instanceof WritableStream))throw new TypeError("StreamTarget requires a WritableStream instance.");if(i!=null&&typeof i!="object")throw new TypeError("StreamTarget options, when provided, must be an object.");if(i.chunked!==void 0&&typeof i.chunked!="boolean")throw new TypeError("options.chunked, when provided, must be a boolean.");if(i.chunkSize!==void 0&&(!Number.isInteger(i.chunkSize)||i.chunkSize<1024))throw new TypeError("options.chunkSize, when provided, must be an integer and not smaller than 1024.");this._writable=e,this._options=i}_createWriter(){return new os(this)}}/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Ue=1e3,cs=2082844800,ls=t=>{const e={},i=t.track;return i.metadata.name!==void 0&&(e.name=i.metadata.name),e},P=(t,e,i=!0)=>{const r=t*e;return i?Math.round(r):r};class us extends Ot{constructor(e,i){super(e),this.auxTarget=new as,this.auxWriter=this.auxTarget._createWriter(),this.auxBoxWriter=new ct(this.auxWriter),this.mdat=null,this.ftypSize=null,this.trackDatas=[],this.allTracksKnown=kt(),this.creationTime=Math.floor(Date.now()/1e3)+cs,this.finalizedChunks=[],this.nextFragmentNumber=1,this.maxWrittenTimestamp=-1/0,this.format=i,this.writer=e._writer,this.boxWriter=new ct(this.writer),this.isQuickTime=i instanceof Yt;const r=this.writer instanceof Kt?"in-memory":!1;this.fastStart=i._options.fastStart??r,this.isFragmented=this.fastStart==="fragmented",(this.fastStart==="in-memory"||this.isFragmented)&&(this.writer.ensureMonotonicity=!0),this.minimumFragmentDuration=i._options.minimumFragmentDuration??1}async start(){const e=await this.mutex.acquire(),i=this.output._tracks.some(r=>r.type==="video"&&r.source._codec==="avc");if(this.format._options.onFtyp&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(Xi({isQuickTime:this.isQuickTime,holdsAvc:i,fragmented:this.isFragmented})),this.format._options.onFtyp){const{data:r,start:s}=this.writer.stopTrackingWrites();this.format._options.onFtyp(r,s)}if(this.ftypSize=this.writer.getPos(),this.fastStart!=="in-memory")if(this.fastStart==="reserve"){for(const r of this.output._tracks)if(r.metadata.maximumPacketCount===void 0)throw new Error("All tracks must specify maximumPacketCount in their metadata when using fastStart: 'reserve'.")}else this.isFragmented||(this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat=he(!0),this.boxWriter.writeBox(this.mdat));await this.writer.flush(),e()}allTracksAreKnown(){for(const e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some(i=>i.track===e))return!1;return!0}async getMimeType(){await this.allTracksKnown.promise;const e=this.trackDatas.map(i=>i.type==="video"||i.type==="audio"?i.info.decoderConfig.codec:{webvtt:"wvtt"}[i.track.source._codec]);return Di({isQuickTime:this.isQuickTime,hasVideo:this.trackDatas.some(i=>i.type==="video"),hasAudio:this.trackDatas.some(i=>i.type==="audio"),codecStrings:e})}getVideoTrackData(e,i,r){const s=this.trackDatas.find(u=>u.track===e);if(s)return s;Et(r),m(r),m(r.decoderConfig);const n={...r.decoderConfig};m(n.codedWidth!==void 0),m(n.codedHeight!==void 0);let o=!1;if(e.source._codec==="avc"&&!n.description){const u=vi(i.data);if(!u)throw new Error("Couldn't extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in AVCC format.");n.description=Pi(u),o=!0}else if(e.source._codec==="hevc"&&!n.description){const u=Bi(i.data);if(!u)throw new Error("Couldn't extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in HEVC format.");n.description=Ri(u),o=!0}const a=ni(1/(e.metadata.frameRate??57600),1e6).denominator,l={muxer:this,track:e,type:"video",info:{width:n.codedWidth,height:n.codedHeight,decoderConfig:n,requiresAnnexBTransformation:o},timescale:a,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(l),this.trackDatas.sort((u,c)=>u.track.id-c.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),l}getAudioTrackData(e,i,r){const s=this.trackDatas.find(l=>l.track===e);if(s)return s;Bt(r),m(r),m(r.decoderConfig);const n={...r.decoderConfig};let o=!1;if(e.source._codec==="aac"&&!n.description){const l=ge(te.tempFromBytes(i.data));if(!l)throw new Error("Couldn't parse ADTS header from the AAC packet. Make sure the packets are in ADTS format (as specified in ISO 13818-7) when not providing a description, or provide a description (must be an AudioSpecificConfig as specified in ISO 14496-3) and ensure the packets are raw AAC data.");const u=Re[l.samplingFrequencyIndex],c=Ie[l.channelConfiguration];if(u===void 0||c===void 0)throw new Error("Invalid ADTS frame header.");n.description=Pt({objectType:l.objectType,sampleRate:u,numberOfChannels:c}),o=!0}const a={muxer:this,track:e,type:"audio",info:{numberOfChannels:r.decoderConfig.numberOfChannels,sampleRate:r.decoderConfig.sampleRate,decoderConfig:n,requiresPcmTransformation:!this.isFragmented&&Q.includes(e.source._codec),requiresAdtsStripping:o,firstPacket:i},timescale:n.sampleRate,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(a),this.trackDatas.sort((l,u)=>l.track.id-u.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),a}getSubtitleTrackData(e,i){const r=this.trackDatas.find(n=>n.track===e);if(r)return r;Ft(i),m(i),m(i.config);const s={muxer:this,track:e,type:"subtitle",info:{config:i.config},timescale:1e3,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[],lastCueEndTimestamp:0,cueQueue:[],nextSourceId:0,cueToSourceId:new WeakMap};return this.trackDatas.push(s),this.trackDatas.sort((n,o)=>n.track.id-o.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),s}async addEncodedVideoPacket(e,i,r){const s=await this.mutex.acquire();try{const n=this.getVideoTrackData(e,i,r);let o=i.data;if(n.info.requiresAnnexBTransformation){const u=[...We(o)].map(c=>o.subarray(c.offset,c.offset+c.length));if(u.length===0)throw new Error("Failed to transform packet data. Make sure all packets are provided in Annex B format, as specified in ITU-T-REC-H.264 and ITU-T-REC-H.265.");o=_i(u,4)}const a=this.validateAndNormalizeTimestamp(n.track,i.timestamp,i.type==="key"),l=this.createSampleForTrack(n,o,a,i.duration,i.type);await this.registerSample(n,l)}finally{s()}}async addEncodedAudioPacket(e,i,r){const s=await this.mutex.acquire();try{const n=this.getAudioTrackData(e,i,r);let o=i.data;if(n.info.requiresAdtsStripping){const u=ge(te.tempFromBytes(o));if(!u)throw new Error("Expected ADTS frame, didn't get one.");const c=u.crcCheck===null?Ut:Vt;o=o.subarray(c)}const a=this.validateAndNormalizeTimestamp(n.track,i.timestamp,i.type==="key"),l=this.createSampleForTrack(n,o,a,i.duration,i.type);n.info.requiresPcmTransformation&&await this.maybePadWithSilence(n,a),await this.registerSample(n,l)}finally{s()}}async maybePadWithSilence(e,i){const r=V(e.samples),s=r?r.timestamp+r.duration:0,n=i-s,o=P(n,e.timescale);if(o>0){const{sampleSize:a,silentValue:l}=ne(e.info.decoderConfig.codec),u=o*e.info.numberOfChannels,c=new Uint8Array(a*u).fill(l),p=this.createSampleForTrack(e,new Uint8Array(c.buffer),s,n,"key");await this.registerSample(e,p)}}async addSubtitleCue(e,i,r){const s=await this.mutex.acquire();try{const n=this.getSubtitleTrackData(e,r);this.validateAndNormalizeTimestamp(n.track,i.timestamp,!0),e.source._codec==="webvtt"&&(n.cueQueue.push(i),await this.processWebVTTCues(n,i.timestamp))}finally{s()}}async processWebVTTCues(e,i){for(;e.cueQueue.length>0;){const r=new Set([]);for(const u of e.cueQueue)m(u.timestamp<=i),m(e.lastCueEndTimestamp<=u.timestamp+u.duration),r.add(Math.max(u.timestamp,e.lastCueEndTimestamp)),r.add(u.timestamp+u.duration);const s=[...r].sort((u,c)=>u-c),n=s[0],o=s[1]??n;if(i<o)break;if(e.lastCueEndTimestamp<n){this.auxWriter.seek(0);const u=Qr();this.auxBoxWriter.writeBox(u);const c=this.auxWriter.getSlice(0,this.auxWriter.getPos()),p=this.createSampleForTrack(e,c,e.lastCueEndTimestamp,n-e.lastCueEndTimestamp,"key");await this.registerSample(e,p),e.lastCueEndTimestamp=n}this.auxWriter.seek(0);for(let u=0;u<e.cueQueue.length;u++){const c=e.cueQueue[u];if(c.timestamp>=o)break;we.lastIndex=0;const p=we.test(c.text),b=c.timestamp+c.duration;let y=e.cueToSourceId.get(c);if(y===void 0&&o<b&&(y=e.nextSourceId++,e.cueToSourceId.set(c,y)),c.notes){const S=Gr(c.notes);this.auxBoxWriter.writeBox(S)}const T=Lr(c.text,p?n:null,c.identifier??null,c.settings??null,y??null);this.auxBoxWriter.writeBox(T),b===o&&e.cueQueue.splice(u--,1)}const a=this.auxWriter.getSlice(0,this.auxWriter.getPos()),l=this.createSampleForTrack(e,a,n,o-n,"key");await this.registerSample(e,l),e.lastCueEndTimestamp=o}}createSampleForTrack(e,i,r,s,n){return{timestamp:r,decodeTimestamp:r,duration:s,data:i,size:i.byteLength,type:n,timescaleUnitsToNextSample:P(s,e.timescale)}}processTimestamps(e,i){if(e.timestampProcessingQueue.length===0)return;if(e.type==="audio"&&e.info.requiresPcmTransformation){let s=0;for(let n=0;n<e.timestampProcessingQueue.length;n++){const o=e.timestampProcessingQueue[n],a=P(o.duration,e.timescale);s+=a}if(e.timeToSampleTable.length===0)e.timeToSampleTable.push({sampleCount:s,sampleDelta:1});else{const n=V(e.timeToSampleTable);n.sampleCount+=s}e.timestampProcessingQueue.length=0;return}const r=e.timestampProcessingQueue.map(s=>s.timestamp).sort((s,n)=>s-n);for(let s=0;s<e.timestampProcessingQueue.length;s++){const n=e.timestampProcessingQueue[s];n.decodeTimestamp=r[s],!this.isFragmented&&e.lastTimescaleUnits===null&&(n.decodeTimestamp=0);const o=P(n.timestamp-n.decodeTimestamp,e.timescale),a=P(n.duration,e.timescale);if(e.lastTimescaleUnits!==null){m(e.lastSample);const l=P(n.decodeTimestamp,e.timescale,!1),u=Math.round(l-e.lastTimescaleUnits);if(m(u>=0),e.lastTimescaleUnits+=u,e.lastSample.timescaleUnitsToNextSample=u,!this.isFragmented){let c=V(e.timeToSampleTable);if(m(c),c.sampleCount===1){c.sampleDelta=u;const b=e.timeToSampleTable[e.timeToSampleTable.length-2];b&&b.sampleDelta===u&&(b.sampleCount++,e.timeToSampleTable.pop(),c=b)}else c.sampleDelta!==u&&(c.sampleCount--,e.timeToSampleTable.push(c={sampleCount:1,sampleDelta:u}));c.sampleDelta===a?c.sampleCount++:e.timeToSampleTable.push({sampleCount:1,sampleDelta:a});const p=V(e.compositionTimeOffsetTable);m(p),p.sampleCompositionTimeOffset===o?p.sampleCount++:e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:o})}}else e.lastTimescaleUnits=P(n.decodeTimestamp,e.timescale,!1),this.isFragmented||(e.timeToSampleTable.push({sampleCount:1,sampleDelta:a}),e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:o}));e.lastSample=n}if(e.timestampProcessingQueue.length=0,m(e.lastSample),m(e.lastTimescaleUnits!==null),i!==void 0&&e.lastSample.timescaleUnitsToNextSample===0){m(i.type==="key");const s=P(i.timestamp,e.timescale,!1),n=Math.round(s-e.lastTimescaleUnits);e.lastSample.timescaleUnitsToNextSample=n}}async registerSample(e,i){i.type==="key"&&this.processTimestamps(e,i),e.timestampProcessingQueue.push(i),this.isFragmented?(e.sampleQueue.push(i),await this.interleaveSamples()):this.fastStart==="reserve"?await this.registerSampleFastStartReserve(e,i):await this.addSampleToTrack(e,i)}async addSampleToTrack(e,i){if(!this.isFragmented&&(e.samples.push(i),this.fastStart==="reserve")){const s=e.track.metadata.maximumPacketCount;if(m(s!==void 0),e.samples.length>s)throw new Error(`Track #${e.track.id} has already reached the maximum packet count (${s}). Either add less packets or increase the maximum packet count.`)}let r=!1;if(!e.currentChunk)r=!0;else{e.currentChunk.startTimestamp=Math.min(e.currentChunk.startTimestamp,i.timestamp);const s=i.timestamp-e.currentChunk.startTimestamp;if(this.isFragmented){const n=this.trackDatas.every(o=>{if(e===o)return i.type==="key";const a=o.sampleQueue[0];return a?a.type==="key":o.track.source._closed});s>=this.minimumFragmentDuration&&n&&i.timestamp>this.maxWrittenTimestamp&&(r=!0,await this.finalizeFragment())}else r=s>=.5}r&&(e.currentChunk&&await this.finalizeCurrentChunk(e),e.currentChunk={startTimestamp:i.timestamp,samples:[],offset:null,moofOffset:null}),m(e.currentChunk),e.currentChunk.samples.push(i),this.isFragmented&&(this.maxWrittenTimestamp=Math.max(this.maxWrittenTimestamp,i.timestamp))}async finalizeCurrentChunk(e){if(m(!this.isFragmented),!e.currentChunk)return;e.finalizedChunks.push(e.currentChunk),this.finalizedChunks.push(e.currentChunk);let i=e.currentChunk.samples.length;if(e.type==="audio"&&e.info.requiresPcmTransformation&&(i=e.currentChunk.samples.reduce((r,s)=>r+P(s.duration,e.timescale),0)),(e.compactlyCodedChunkTable.length===0||V(e.compactlyCodedChunkTable).samplesPerChunk!==i)&&e.compactlyCodedChunkTable.push({firstChunk:e.finalizedChunks.length,samplesPerChunk:i}),this.fastStart==="in-memory"){e.currentChunk.offset=0;return}e.currentChunk.offset=this.writer.getPos();for(const r of e.currentChunk.samples)m(r.data),this.writer.write(r.data),r.data=null;await this.writer.flush()}async interleaveSamples(e=!1){if(m(this.isFragmented),!(!e&&!this.allTracksAreKnown()))e:for(;;){let i=null,r=1/0;for(const n of this.trackDatas){if(!e&&n.sampleQueue.length===0&&!n.track.source._closed)break e;n.sampleQueue.length>0&&n.sampleQueue[0].timestamp<r&&(i=n,r=n.sampleQueue[0].timestamp)}if(!i)break;const s=i.sampleQueue.shift();await this.addSampleToTrack(i,s)}}async finalizeFragment(e=!0){m(this.isFragmented);const i=this.nextFragmentNumber++;if(i===1){this.format._options.onMoov&&this.writer.startTrackingWrites();const y=le(this);if(this.boxWriter.writeBox(y),this.format._options.onMoov){const{data:T,start:S}=this.writer.stopTrackingWrites();this.format._options.onMoov(T,S)}}const r=this.trackDatas.filter(y=>y.currentChunk),s=ut(i,r),n=this.writer.getPos(),o=n+this.boxWriter.measureBox(s);let a=o+_e,l=1/0;for(const y of r){y.currentChunk.offset=a,y.currentChunk.moofOffset=n;for(const T of y.currentChunk.samples)a+=T.size;l=Math.min(l,y.currentChunk.startTimestamp)}const u=a-o,c=u>=2**32;if(c)for(const y of r)y.currentChunk.offset+=st-_e;this.format._options.onMoof&&this.writer.startTrackingWrites();const p=ut(i,r);if(this.boxWriter.writeBox(p),this.format._options.onMoof){const{data:y,start:T}=this.writer.stopTrackingWrites();this.format._options.onMoof(y,T,l)}m(this.writer.getPos()===o),this.format._options.onMdat&&this.writer.startTrackingWrites();const b=he(c);b.size=u,this.boxWriter.writeBox(b),this.writer.seek(o+(c?st:_e));for(const y of r)for(const T of y.currentChunk.samples)this.writer.write(T.data),T.data=null;if(this.format._options.onMdat){const{data:y,start:T}=this.writer.stopTrackingWrites();this.format._options.onMdat(y,T)}for(const y of r)y.finalizedChunks.push(y.currentChunk),this.finalizedChunks.push(y.currentChunk),y.currentChunk=null;e&&await this.writer.flush()}async registerSampleFastStartReserve(e,i){if(this.allTracksAreKnown()){if(!this.mdat){const r=le(this),n=this.boxWriter.measureBox(r)+this.computeSampleTableSizeUpperBound()+4096;m(this.ftypSize!==null),this.writer.seek(this.ftypSize+n),this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat=he(!0),this.boxWriter.writeBox(this.mdat);for(const o of this.trackDatas){for(const a of o.sampleQueue)await this.addSampleToTrack(o,a);o.sampleQueue.length=0}}await this.addSampleToTrack(e,i)}else e.sampleQueue.push(i)}computeSampleTableSizeUpperBound(){m(this.fastStart==="reserve");let e=0;for(const i of this.trackDatas){const r=i.track.metadata.maximumPacketCount;m(r!==void 0),e+=8*Math.ceil(2/3*r),e+=4*r,e+=8*Math.ceil(2/3*r),e+=12*Math.ceil(2/3*r),e+=4*r,e+=8*r}return e}async onTrackClose(e){const i=await this.mutex.acquire();if(e.type==="subtitle"&&e.source._codec==="webvtt"){const r=this.trackDatas.find(s=>s.track===e);r&&await this.processWebVTTCues(r,1/0)}this.allTracksAreKnown()&&this.allTracksKnown.resolve(),this.isFragmented&&await this.interleaveSamples(),i()}async finalize(){const e=await this.mutex.acquire();this.allTracksKnown.resolve();for(const i of this.trackDatas)i.type==="subtitle"&&i.track.source._codec==="webvtt"&&await this.processWebVTTCues(i,1/0);if(this.isFragmented){await this.interleaveSamples(!0);for(const i of this.trackDatas)this.processTimestamps(i);await this.finalizeFragment(!1)}else for(const i of this.trackDatas)this.processTimestamps(i),await this.finalizeCurrentChunk(i);if(this.fastStart==="in-memory"){this.mdat=he(!1);let i;for(let s=0;s<2;s++){const n=le(this),o=this.boxWriter.measureBox(n);i=this.boxWriter.measureBox(this.mdat);let a=this.writer.getPos()+o+i;for(const l of this.finalizedChunks){l.offset=a;for(const{data:u}of l.samples)m(u),a+=u.byteLength,i+=u.byteLength}if(a<2**32)break;i>=2**32&&(this.mdat.largeSize=!0)}this.format._options.onMoov&&this.writer.startTrackingWrites();const r=le(this);if(this.boxWriter.writeBox(r),this.format._options.onMoov){const{data:s,start:n}=this.writer.stopTrackingWrites();this.format._options.onMoov(s,n)}this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat.size=i,this.boxWriter.writeBox(this.mdat);for(const s of this.finalizedChunks)for(const n of s.samples)m(n.data),this.writer.write(n.data),n.data=null;if(this.format._options.onMdat){const{data:s,start:n}=this.writer.stopTrackingWrites();this.format._options.onMdat(s,n)}}else if(this.isFragmented){const i=this.writer.getPos(),r=$r(this.trackDatas);this.boxWriter.writeBox(r);const s=this.writer.getPos()-i;this.writer.seek(this.writer.getPos()-4),this.boxWriter.writeU32(s)}else{m(this.mdat);const i=this.boxWriter.offsets.get(this.mdat);m(i!==void 0);const r=this.writer.getPos()-i;if(this.mdat.size=r,this.mdat.largeSize=r>=2**32,this.boxWriter.patchBox(this.mdat),this.format._options.onMdat){const{data:n,start:o}=this.writer.stopTrackingWrites();this.format._options.onMdat(n,o)}const s=le(this);if(this.fastStart==="reserve"){m(this.ftypSize!==null),this.writer.seek(this.ftypSize),this.format._options.onMoov&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(s);const n=this.boxWriter.offsets.get(this.mdat)-this.writer.getPos();this.boxWriter.writeBox(Yi(n))}else this.format._options.onMoov&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(s);if(this.format._options.onMoov){const{data:n,start:o}=this.writer.stopTrackingWrites();this.format._options.onMoov(n,o)}}e()}}/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const ds=-32768,fs=2**15-1,ft="Mediabunny",ht=6,mt=5,hs={video:1,audio:2,subtitle:17};class ms extends Ot{constructor(e,i){super(e),this.trackDatas=[],this.allTracksKnown=kt(),this.segment=null,this.segmentInfo=null,this.seekHead=null,this.tracksElement=null,this.tagsElement=null,this.attachmentsElement=null,this.segmentDuration=null,this.cues=null,this.currentCluster=null,this.currentClusterStartMsTimestamp=null,this.currentClusterMaxMsTimestamp=null,this.trackDatasInCurrentCluster=new Map,this.duration=0,this.writer=e._writer,this.format=i,this.ebmlWriter=new $i(this.writer),this.format._options.appendOnly&&(this.writer.ensureMonotonicity=!0)}async start(){const e=await this.mutex.acquire();this.writeEBMLHeader(),this.createSegmentInfo(),this.createCues(),await this.writer.flush(),e()}writeEBMLHeader(){this.format._options.onEbmlHeader&&this.writer.startTrackingWrites();const e={id:d.EBML,data:[{id:d.EBMLVersion,data:1},{id:d.EBMLReadVersion,data:1},{id:d.EBMLMaxIDLength,data:4},{id:d.EBMLMaxSizeLength,data:8},{id:d.DocType,data:this.format instanceof gt?"webm":"matroska"},{id:d.DocTypeVersion,data:2},{id:d.DocTypeReadVersion,data:2}]};if(this.ebmlWriter.writeEBML(e),this.format._options.onEbmlHeader){const{data:i,start:r}=this.writer.stopTrackingWrites();this.format._options.onEbmlHeader(i,r)}}maybeCreateSeekHead(e){if(this.format._options.appendOnly)return;const i=new Uint8Array([28,83,187,107]),r=new Uint8Array([21,73,169,102]),s=new Uint8Array([22,84,174,107]),n=new Uint8Array([25,65,164,105]),o=new Uint8Array([18,84,195,103]),a={id:d.SeekHead,data:[{id:d.Seek,data:[{id:d.SeekID,data:i},{id:d.SeekPosition,size:5,data:e?this.ebmlWriter.offsets.get(this.cues)-this.segmentDataOffset:0}]},{id:d.Seek,data:[{id:d.SeekID,data:r},{id:d.SeekPosition,size:5,data:e?this.ebmlWriter.offsets.get(this.segmentInfo)-this.segmentDataOffset:0}]},{id:d.Seek,data:[{id:d.SeekID,data:s},{id:d.SeekPosition,size:5,data:e?this.ebmlWriter.offsets.get(this.tracksElement)-this.segmentDataOffset:0}]},this.attachmentsElement?{id:d.Seek,data:[{id:d.SeekID,data:n},{id:d.SeekPosition,size:5,data:e?this.ebmlWriter.offsets.get(this.attachmentsElement)-this.segmentDataOffset:0}]}:null,this.tagsElement?{id:d.Seek,data:[{id:d.SeekID,data:o},{id:d.SeekPosition,size:5,data:e?this.ebmlWriter.offsets.get(this.tagsElement)-this.segmentDataOffset:0}]}:null]};this.seekHead=a}createSegmentInfo(){const e={id:d.Duration,data:new ze(0)};this.segmentDuration=e;const i={id:d.Info,data:[{id:d.TimestampScale,data:1e6},{id:d.MuxingApp,data:ft},{id:d.WritingApp,data:ft},this.format._options.appendOnly?null:e]};this.segmentInfo=i}createTracks(){var i,r,s,n,o,a;const e={id:d.Tracks,data:[]};this.tracksElement=e;for(const l of this.trackDatas){const u=ji[l.track.source._codec];m(u);let c=0;if(l.type==="audio"&&l.track.source._codec==="opus"){c=1e6*80;const p=l.info.decoderConfig.description;if(p){const b=Z(p),y=Mt(b);c=Math.round(1e9*(y.preSkip/hi))}}e.data.push({id:d.TrackEntry,data:[{id:d.TrackNumber,data:l.track.id},{id:d.TrackUID,data:l.track.id},{id:d.TrackType,data:hs[l.type]},((i=l.track.metadata.disposition)==null?void 0:i.default)===!1?{id:d.FlagDefault,data:0}:null,(r=l.track.metadata.disposition)!=null&&r.forced?{id:d.FlagForced,data:1}:null,(s=l.track.metadata.disposition)!=null&&s.hearingImpaired?{id:d.FlagHearingImpaired,data:1}:null,(n=l.track.metadata.disposition)!=null&&n.visuallyImpaired?{id:d.FlagVisualImpaired,data:1}:null,(o=l.track.metadata.disposition)!=null&&o.original?{id:d.FlagOriginal,data:1}:null,(a=l.track.metadata.disposition)!=null&&a.commentary?{id:d.FlagCommentary,data:1}:null,{id:d.FlagLacing,data:0},{id:d.Language,data:l.track.metadata.languageCode??St},{id:d.CodecID,data:u},{id:d.CodecDelay,data:0},{id:d.SeekPreRoll,data:c},l.track.metadata.name!==void 0?{id:d.Name,data:new X(l.track.metadata.name)}:null,l.type==="video"?this.videoSpecificTrackInfo(l):null,l.type==="audio"?this.audioSpecificTrackInfo(l):null,l.type==="subtitle"?this.subtitleSpecificTrackInfo(l):null]})}}videoSpecificTrackInfo(e){const{frameRate:i,rotation:r}=e.track.metadata,s=[e.info.decoderConfig.description?{id:d.CodecPrivate,data:Z(e.info.decoderConfig.description)}:null,i?{id:d.DefaultDuration,data:1e9/i}:null],n=r?ei(-r):0,o=e.info.decoderConfig.colorSpace,a={id:d.Video,data:[{id:d.PixelWidth,data:e.info.width},{id:d.PixelHeight,data:e.info.height},e.info.alphaMode?{id:d.AlphaMode,data:1}:null,bt(o)?{id:d.Colour,data:[{id:d.MatrixCoefficients,data:Te[o.matrix]},{id:d.TransferCharacteristics,data:be[o.transfer]},{id:d.Primaries,data:ye[o.primaries]},{id:d.Range,data:o.fullRange?2:1}]}:null,n?{id:d.Projection,data:[{id:d.ProjectionType,data:0},{id:d.ProjectionPoseRoll,data:new Me((n+180)%360-180)}]}:null]};return s.push(a),s}audioSpecificTrackInfo(e){const i=Q.includes(e.track.source._codec)?ne(e.track.source._codec):null;return[e.info.decoderConfig.description?{id:d.CodecPrivate,data:Z(e.info.decoderConfig.description)}:null,{id:d.Audio,data:[{id:d.SamplingFrequency,data:new Me(e.info.sampleRate)},{id:d.Channels,data:e.info.numberOfChannels},i?{id:d.BitDepth,data:8*i.sampleSize}:null]}]}subtitleSpecificTrackInfo(e){return[{id:d.CodecPrivate,data:E.encode(e.info.config.description)}]}maybeCreateTags(){const e=[],i=(n,o)=>{e.push({id:d.SimpleTag,data:[{id:d.TagName,data:new X(n)},typeof o=="string"?{id:d.TagString,data:new X(o)}:{id:d.TagBinary,data:o}]})},r=this.output._metadataTags,s=new Set;for(const{key:n,value:o}of Ve(r))switch(n){case"title":i("TITLE",o),s.add("TITLE");break;case"description":i("DESCRIPTION",o),s.add("DESCRIPTION");break;case"artist":i("ARTIST",o),s.add("ARTIST");break;case"album":i("ALBUM",o),s.add("ALBUM");break;case"albumArtist":i("ALBUM_ARTIST",o),s.add("ALBUM_ARTIST");break;case"genre":i("GENRE",o),s.add("GENRE");break;case"comment":i("COMMENT",o),s.add("COMMENT");break;case"lyrics":i("LYRICS",o),s.add("LYRICS");break;case"date":i("DATE",o.toISOString().slice(0,10)),s.add("DATE");break;case"trackNumber":{const a=r.tracksTotal!==void 0?`${o}/${r.tracksTotal}`:o.toString();i("PART_NUMBER",a),s.add("PART_NUMBER")}break;case"discNumber":{const a=r.discsTotal!==void 0?`${o}/${r.discsTotal}`:o.toString();i("DISC",a),s.add("DISC")}break;case"tracksTotal":case"discsTotal":break;case"images":case"raw":break;default:Ce(n)}if(r.raw)for(const n in r.raw){const o=r.raw[n];o==null||s.has(n)||(typeof o=="string"||o instanceof Uint8Array)&&i(n,o)}e.length!==0&&(this.tagsElement={id:d.Tags,data:[{id:d.Tag,data:[{id:d.Targets,data:[{id:d.TargetTypeValue,data:50},{id:d.TargetType,data:"MOVIE"}]},...e]}]})}maybeCreateAttachments(){const e=this.output._metadataTags,i=[],r=new Set,s=e.images??[];for(const n of s){let o=n.name;o===void 0&&(o=(n.kind==="coverFront"?"cover":n.kind==="coverBack"?"back":"image")+(ai(n.mimeType)??""));let a;for(;;){a=0n;for(let l=0;l<8;l++)a<<=8n,a|=BigInt(Math.floor(Math.random()*256));if(a!==0n&&!r.has(a))break}r.add(a),i.push({id:d.AttachedFile,data:[n.description!==void 0?{id:d.FileDescription,data:new X(n.description)}:null,{id:d.FileName,data:new X(o)},{id:d.FileMediaType,data:n.mimeType},{id:d.FileData,data:n.data},{id:d.FileUID,data:a}]})}for(const[n,o]of Object.entries(e.raw??{}))!(o instanceof _t)||!/^\d+$/.test(n)||s.find(l=>l.mimeType===o.mimeType&&ci(l.data,o.data))||i.push({id:d.AttachedFile,data:[o.description!==void 0?{id:d.FileDescription,data:new X(o.description)}:null,{id:d.FileName,data:new X(o.name??"")},{id:d.FileMediaType,data:o.mimeType??""},{id:d.FileData,data:o.data},{id:d.FileUID,data:BigInt(n)}]});i.length!==0&&(this.attachmentsElement={id:d.Attachments,data:i})}createSegment(){this.createTracks(),this.maybeCreateTags(),this.maybeCreateAttachments(),this.maybeCreateSeekHead(!1);const e={id:d.Segment,size:this.format._options.appendOnly?-1:ht,data:[this.seekHead,this.segmentInfo,this.tracksElement,this.attachmentsElement,this.tagsElement]};if(this.segment=e,this.format._options.onSegmentHeader&&this.writer.startTrackingWrites(),this.ebmlWriter.writeEBML(e),this.format._options.onSegmentHeader){const{data:i,start:r}=this.writer.stopTrackingWrites();this.format._options.onSegmentHeader(i,r)}}createCues(){this.cues={id:d.Cues,data:[]}}get segmentDataOffset(){return m(this.segment),this.ebmlWriter.dataOffsets.get(this.segment)}allTracksAreKnown(){for(const e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some(i=>i.track===e))return!1;return!0}async getMimeType(){await this.allTracksKnown.promise;const e=this.trackDatas.map(i=>i.type==="video"||i.type==="audio"?i.info.decoderConfig.codec:{webvtt:"wvtt"}[i.track.source._codec]);return qi({isWebM:this.format instanceof gt,hasVideo:this.trackDatas.some(i=>i.type==="video"),hasAudio:this.trackDatas.some(i=>i.type==="audio"),codecStrings:e})}getVideoTrackData(e,i,r){const s=this.trackDatas.find(o=>o.track===e);if(s)return s;Et(r),m(r),m(r.decoderConfig),m(r.decoderConfig.codedWidth!==void 0),m(r.decoderConfig.codedHeight!==void 0);const n={track:e,type:"video",info:{width:r.decoderConfig.codedWidth,height:r.decoderConfig.codedHeight,decoderConfig:r.decoderConfig,alphaMode:!!i.sideData.alpha},chunkQueue:[],lastWrittenMsTimestamp:null};return e.source._codec==="vp9"?n.info.decoderConfig={...n.info.decoderConfig,description:new Uint8Array(fi(n.info.decoderConfig.codec))}:e.source._codec==="av1"&&(n.info.decoderConfig={...n.info.decoderConfig,description:new Uint8Array(vt(n.info.decoderConfig.codec))}),this.trackDatas.push(n),this.trackDatas.sort((o,a)=>o.track.id-a.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),n}getAudioTrackData(e,i,r){const s=this.trackDatas.find(l=>l.track===e);if(s)return s;Bt(r),m(r),m(r.decoderConfig);const n={...r.decoderConfig};let o=!1;if(e.source._codec==="aac"&&!n.description){const l=ge(te.tempFromBytes(i.data));if(!l)throw new Error("Couldn't parse ADTS header from the AAC packet. Make sure the packets are in ADTS format (as specified in ISO 13818-7) when not providing a description, or provide a description (must be an AudioSpecificConfig as specified in ISO 14496-3) and ensure the packets are raw AAC data.");const u=Re[l.samplingFrequencyIndex],c=Ie[l.channelConfiguration];if(u===void 0||c===void 0)throw new Error("Invalid ADTS frame header.");n.description=Pt({objectType:l.objectType,sampleRate:u,numberOfChannels:c}),o=!0}const a={track:e,type:"audio",info:{numberOfChannels:r.decoderConfig.numberOfChannels,sampleRate:r.decoderConfig.sampleRate,decoderConfig:n,requiresAdtsStripping:o},chunkQueue:[],lastWrittenMsTimestamp:null};return this.trackDatas.push(a),this.trackDatas.sort((l,u)=>l.track.id-u.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),a}getSubtitleTrackData(e,i){const r=this.trackDatas.find(n=>n.track===e);if(r)return r;Ft(i),m(i),m(i.config);const s={track:e,type:"subtitle",info:{config:i.config},chunkQueue:[],lastWrittenMsTimestamp:null};return this.trackDatas.push(s),this.trackDatas.sort((n,o)=>n.track.id-o.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),s}async addEncodedVideoPacket(e,i,r){const s=await this.mutex.acquire();try{const n=this.getVideoTrackData(e,i,r),o=i.type==="key";let a=this.validateAndNormalizeTimestamp(n.track,i.timestamp,o),l=i.duration;e.metadata.frameRate!==void 0&&(a=Le(a,1/e.metadata.frameRate),l=Le(l,1/e.metadata.frameRate));const u=n.info.alphaMode?i.sideData.alpha??null:null,c=this.createInternalChunk(i.data,a,l,i.type,u);e.source._codec==="vp9"&&this.fixVP9ColorSpace(n,c),n.chunkQueue.push(c),await this.interleaveChunks()}finally{s()}}async addEncodedAudioPacket(e,i,r){const s=await this.mutex.acquire();try{const n=this.getAudioTrackData(e,i,r);let o=i.data;if(n.info.requiresAdtsStripping){const c=ge(te.tempFromBytes(o));if(!c)throw new Error("Expected ADTS frame, didn't get one.");const p=c.crcCheck===null?Ut:Vt;o=o.subarray(p)}const a=i.type==="key",l=this.validateAndNormalizeTimestamp(n.track,i.timestamp,a),u=this.createInternalChunk(o,l,i.duration,i.type);n.chunkQueue.push(u),await this.interleaveChunks()}finally{s()}}async addSubtitleCue(e,i,r){const s=await this.mutex.acquire();try{const n=this.getSubtitleTrackData(e,r),o=this.validateAndNormalizeTimestamp(n.track,i.timestamp,!0);let a=i.text;const l=Math.round(o*1e3);we.lastIndex=0,a=a.replace(we,b=>{const T=Ki(b.slice(1,-1))-l;return`<${Rt(T)}>`});const u=E.encode(a),c=`${i.settings??""}
${i.identifier??""}
${i.notes??""}`,p=this.createInternalChunk(u,o,i.duration,"key",c.trim()?E.encode(c):null);n.chunkQueue.push(p),await this.interleaveChunks()}finally{s()}}async interleaveChunks(e=!1){if(!(!e&&!this.allTracksAreKnown())){e:for(;;){let i=null,r=1/0;for(const n of this.trackDatas){if(!e&&n.chunkQueue.length===0&&!n.track.source._closed)break e;n.chunkQueue.length>0&&n.chunkQueue[0].timestamp<r&&(i=n,r=n.chunkQueue[0].timestamp)}if(!i)break;const s=i.chunkQueue.shift();this.writeBlock(i,s)}e||await this.writer.flush()}}fixVP9ColorSpace(e,i){if(i.type!=="key"||!e.info.decoderConfig.colorSpace||!e.info.decoderConfig.colorSpace.matrix)return;const r=new z(i.data);r.skipBits(2);const s=r.readBits(1),o=(r.readBits(1)<<1)+s;if(o===3&&r.skipBits(1),r.readBits(1)||r.readBits(1)!==0||(r.skipBits(2),r.readBits(24)!==4817730))return;o>=2&&r.skipBits(1);const c={rgb:7,bt709:2,bt470bg:1,smpte170m:3}[e.info.decoderConfig.colorSpace.matrix];ti(i.data,r.pos,r.pos+3,c)}createInternalChunk(e,i,r,s,n=null){return{data:e,type:s,timestamp:i,duration:r,additions:n}}writeBlock(e,i){this.segment||this.createSegment();const r=Math.round(1e3*i.timestamp),s=this.trackDatas.every(c=>{if(e===c)return i.type==="key";const p=c.chunkQueue[0];return p?p.type==="key":c.track.source._closed});let n=!1;if(!this.currentCluster)n=!0;else{m(this.currentClusterStartMsTimestamp!==null),m(this.currentClusterMaxMsTimestamp!==null);const c=r-this.currentClusterStartMsTimestamp;n=s&&r>this.currentClusterMaxMsTimestamp&&c>=1e3*(this.format._options.minimumClusterDuration??1)||c>fs}n&&this.createNewCluster(r);const o=r-this.currentClusterStartMsTimestamp;if(o<ds)return;const a=new Uint8Array(4),l=new DataView(a.buffer);l.setUint8(0,128|e.track.id),l.setInt16(1,o,!1);const u=Math.round(1e3*i.duration);if(i.additions){const c={id:d.BlockGroup,data:[{id:d.Block,data:[a,i.data]},i.type==="delta"?{id:d.ReferenceBlock,data:new zt(e.lastWrittenMsTimestamp-r)}:null,i.additions?{id:d.BlockAdditions,data:[{id:d.BlockMore,data:[{id:d.BlockAddID,data:1},{id:d.BlockAdditional,data:i.additions}]}]}:null,u>0?{id:d.BlockDuration,data:u}:null]};this.ebmlWriter.writeEBML(c)}else{l.setUint8(3,+(i.type==="key")<<7);const c={id:d.SimpleBlock,data:[a,i.data]};this.ebmlWriter.writeEBML(c)}this.duration=Math.max(this.duration,r+u),e.lastWrittenMsTimestamp=r,this.trackDatasInCurrentCluster.has(e)||this.trackDatasInCurrentCluster.set(e,{firstMsTimestamp:r}),this.currentClusterMaxMsTimestamp=Math.max(this.currentClusterMaxMsTimestamp,r)}createNewCluster(e){this.currentCluster&&this.finalizeCurrentCluster(),this.format._options.onCluster&&this.writer.startTrackingWrites(),this.currentCluster={id:d.Cluster,size:this.format._options.appendOnly?-1:mt,data:[{id:d.Timestamp,data:e}]},this.ebmlWriter.writeEBML(this.currentCluster),this.currentClusterStartMsTimestamp=e,this.currentClusterMaxMsTimestamp=e,this.trackDatasInCurrentCluster.clear()}finalizeCurrentCluster(){if(m(this.currentCluster),!this.format._options.appendOnly){const s=this.writer.getPos()-this.ebmlWriter.dataOffsets.get(this.currentCluster),n=this.writer.getPos();this.writer.seek(this.ebmlWriter.offsets.get(this.currentCluster)+4),this.ebmlWriter.writeVarInt(s,mt),this.writer.seek(n)}if(this.format._options.onCluster){m(this.currentClusterStartMsTimestamp!==null);const{data:s,start:n}=this.writer.stopTrackingWrites();this.format._options.onCluster(s,n,this.currentClusterStartMsTimestamp/1e3)}const e=this.ebmlWriter.offsets.get(this.currentCluster)-this.segmentDataOffset,i=new Map;for(const[s,{firstMsTimestamp:n}]of this.trackDatasInCurrentCluster)i.has(n)||i.set(n,[]),i.get(n).push(s);const r=[...i.entries()].sort((s,n)=>s[0]-n[0]);for(const[s,n]of r)m(this.cues),this.cues.data.push({id:d.CuePoint,data:[{id:d.CueTime,data:s},...n.map(o=>({id:d.CueTrackPositions,data:[{id:d.CueTrack,data:o.track.id},{id:d.CueClusterPosition,data:e}]}))]})}async onTrackClose(){const e=await this.mutex.acquire();this.allTracksAreKnown()&&this.allTracksKnown.resolve(),await this.interleaveChunks(),e()}async finalize(){const e=await this.mutex.acquire();if(this.allTracksKnown.resolve(),this.segment||this.createSegment(),await this.interleaveChunks(!0),this.currentCluster&&this.finalizeCurrentCluster(),m(this.cues),this.ebmlWriter.writeEBML(this.cues),!this.format._options.appendOnly){const i=this.writer.getPos(),r=this.writer.getPos()-this.segmentDataOffset;this.writer.seek(this.ebmlWriter.offsets.get(this.segment)+4),this.ebmlWriter.writeVarInt(r,ht),this.segmentDuration.data=new ze(this.duration),this.writer.seek(this.ebmlWriter.offsets.get(this.segmentDuration)),this.ebmlWriter.writeEBML(this.segmentDuration),m(this.seekHead),this.writer.seek(this.ebmlWriter.offsets.get(this.seekHead)),this.maybeCreateSeekHead(!0),this.ebmlWriter.writeEBML(this.seekHead),this.writer.seek(i)}e()}}/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class je{getSupportedVideoCodecs(){return this.getSupportedCodecs().filter(e=>J.includes(e))}getSupportedAudioCodecs(){return this.getSupportedCodecs().filter(e=>de.includes(e))}getSupportedSubtitleCodecs(){return this.getSupportedCodecs().filter(e=>se.includes(e))}_codecUnsupportedHint(e){return""}}class Xt extends je{constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.fastStart!==void 0&&![!1,"in-memory","reserve","fragmented"].includes(e.fastStart))throw new TypeError("options.fastStart, when provided, must be false, 'in-memory', 'reserve', or 'fragmented'.");if(e.minimumFragmentDuration!==void 0&&(!Number.isFinite(e.minimumFragmentDuration)||e.minimumFragmentDuration<0))throw new TypeError("options.minimumFragmentDuration, when provided, must be a non-negative number.");if(e.onFtyp!==void 0&&typeof e.onFtyp!="function")throw new TypeError("options.onFtyp, when provided, must be a function.");if(e.onMoov!==void 0&&typeof e.onMoov!="function")throw new TypeError("options.onMoov, when provided, must be a function.");if(e.onMdat!==void 0&&typeof e.onMdat!="function")throw new TypeError("options.onMdat, when provided, must be a function.");if(e.onMoof!==void 0&&typeof e.onMoof!="function")throw new TypeError("options.onMoof, when provided, must be a function.");if(e.metadataFormat!==void 0&&!["mdir","mdta","udta","auto"].includes(e.metadataFormat))throw new TypeError("options.metadataFormat, when provided, must be either 'auto', 'mdir', 'mdta', or 'udta'.");super(),this._options=e}getSupportedTrackCounts(){return{video:{min:0,max:4294967295},audio:{min:0,max:4294967295},subtitle:{min:0,max:4294967295},total:{min:1,max:4294967295}}}get supportsVideoRotationMetadata(){return!0}get supportsTimestampedMediaData(){return!0}_createMuxer(e){return new us(e,this)}}class ps extends Xt{constructor(e){super(e)}get _name(){return"MP4"}get fileExtension(){return".mp4"}get mimeType(){return"video/mp4"}getSupportedCodecs(){return[...J,...Oe,"pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be",...se]}_codecUnsupportedHint(e){return new Yt().getSupportedCodecs().includes(e)?" Switching to MOV will grant support for this codec.":""}}class Yt extends Xt{constructor(e){super(e)}get _name(){return"MOV"}get fileExtension(){return".mov"}get mimeType(){return"video/quicktime"}getSupportedCodecs(){return[...J,...de]}_codecUnsupportedHint(e){return new ps().getSupportedCodecs().includes(e)?" Switching to MP4 will grant support for this codec.":""}}class pt extends je{constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.appendOnly!==void 0&&typeof e.appendOnly!="boolean")throw new TypeError("options.appendOnly, when provided, must be a boolean.");if(e.minimumClusterDuration!==void 0&&(!Number.isFinite(e.minimumClusterDuration)||e.minimumClusterDuration<0))throw new TypeError("options.minimumClusterDuration, when provided, must be a non-negative number.");if(e.onEbmlHeader!==void 0&&typeof e.onEbmlHeader!="function")throw new TypeError("options.onEbmlHeader, when provided, must be a function.");if(e.onSegmentHeader!==void 0&&typeof e.onSegmentHeader!="function")throw new TypeError("options.onHeader, when provided, must be a function.");if(e.onCluster!==void 0&&typeof e.onCluster!="function")throw new TypeError("options.onCluster, when provided, must be a function.");super(),this._options=e}_createMuxer(e){return new ms(e,this)}get _name(){return"Matroska"}getSupportedTrackCounts(){return{video:{min:0,max:127},audio:{min:0,max:127},subtitle:{min:0,max:127},total:{min:1,max:127}}}get fileExtension(){return".mkv"}get mimeType(){return"video/x-matroska"}getSupportedCodecs(){return[...J,...Oe,...Q.filter(e=>!["pcm-s8","pcm-f32be","pcm-f64be","ulaw","alaw"].includes(e)),...se]}get supportsVideoRotationMetadata(){return!1}get supportsTimestampedMediaData(){return!0}}class gt extends pt{constructor(e){super(e)}getSupportedCodecs(){return[...J.filter(e=>["vp8","vp9","av1"].includes(e)),...de.filter(e=>["opus","vorbis"].includes(e)),...se]}get _name(){return"WebM"}get fileExtension(){return".webm"}get mimeType(){return"video/webm"}_codecUnsupportedHint(e){return new pt().getSupportedCodecs().includes(e)?" Switching to MKV will grant support for this codec.":""}}/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const gs=(t,e)=>{if(!e||typeof e!="object")throw new TypeError("Encoding options must be an object.");if(e.alpha!==void 0&&!["discard","keep"].includes(e.alpha))throw new TypeError("options.alpha, when provided, must be 'discard' or 'keep'.");if(e.bitrateMode!==void 0&&!["constant","variable"].includes(e.bitrateMode))throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");if(e.latencyMode!==void 0&&!["quality","realtime"].includes(e.latencyMode))throw new TypeError("latencyMode, when provided, must be 'quality' or 'realtime'.");if(e.fullCodecString!==void 0&&typeof e.fullCodecString!="string")throw new TypeError("fullCodecString, when provided, must be a string.");if(e.fullCodecString!==void 0&&mi(e.fullCodecString)!==t)throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${t}).`);if(e.hardwareAcceleration!==void 0&&!["no-preference","prefer-hardware","prefer-software"].includes(e.hardwareAcceleration))throw new TypeError("hardwareAcceleration, when provided, must be 'no-preference', 'prefer-hardware' or 'prefer-software'.");if(e.scalabilityMode!==void 0&&typeof e.scalabilityMode!="string")throw new TypeError("scalabilityMode, when provided, must be a string.");if(e.contentHint!==void 0&&typeof e.contentHint!="string")throw new TypeError("contentHint, when provided, must be a string.")},wt=t=>{const e=t.bitrate instanceof Zt?t.bitrate._toVideoBitrate(t.codec,t.width,t.height):t.bitrate;return{codec:t.fullCodecString??di(t.codec,t.width,t.height,e),width:t.width,height:t.height,bitrate:e,bitrateMode:t.bitrateMode,alpha:t.alpha??"discard",framerate:t.framerate,latencyMode:t.latencyMode,hardwareAcceleration:t.hardwareAcceleration,scalabilityMode:t.scalabilityMode,contentHint:t.contentHint,...pi(t.codec)}};class Zt{constructor(e){this._factor=e}_toVideoBitrate(e,i,r){const s=i*r,n={avc:1,hevc:.6,vp9:.6,av1:.4,vp8:1.2},o=1920*1080,a=3e6,l=Math.pow(s/o,.95),p=a*l*n[e]*this._factor;return Math.ceil(p/1e3)*1e3}_toAudioBitrate(e){if(Q.includes(e)||e==="flac")return;const r={aac:128e3,opus:64e3,mp3:16e4,vorbis:64e3,ac3:384e3,eac3:192e3}[e];if(!r)throw new Error(`Unhandled codec: ${e}`);let s=r*this._factor;return e==="aac"?s=[96e3,128e3,16e4,192e3].reduce((o,a)=>Math.abs(a-s)<Math.abs(o-s)?a:o):e==="opus"||e==="vorbis"?s=Math.max(6e3,s):e==="mp3"&&(s=[8e3,16e3,24e3,32e3,4e4,48e3,64e3,8e4,96e3,112e3,128e3,16e4,192e3,224e3,256e3,32e4].reduce((o,a)=>Math.abs(a-s)<Math.abs(o-s)?a:o)),Math.round(s/1e3)*1e3}}const Cs=async(t,e={})=>{const{width:i=1280,height:r=720,bitrate:s=1e6,...n}=e;if(!J.includes(t))return!1;if(!Number.isInteger(i)||i<=0)throw new TypeError("width must be a positive integer.");if(!Number.isInteger(r)||r<=0)throw new TypeError("height must be a positive integer.");if(!(s instanceof Zt)&&(!Number.isInteger(s)||s<=0))throw new TypeError("bitrate must be a positive integer or a quality.");gs(t,n);let o=null;return it.length>0&&(o??(o=wt({codec:t,width:i,height:r,bitrate:s,framerate:void 0,...n})),it.some(u=>u.supports(t,o)))?!0:typeof VideoEncoder>"u"||(i%2===1||r%2===1)&&(t==="avc"||t==="hevc")||(o??(o=wt({codec:t,width:i,height:r,bitrate:s,framerate:void 0,...n,alpha:"discard"})),!(await VideoEncoder.isConfigSupported(o)).supported)?!1:oi()?new Promise(async u=>{try{const c=new VideoEncoder({output:()=>{},error:()=>u(!1)});c.configure(o);const p=new Uint8Array(i*r*4),b=new VideoFrame(p,{format:"RGBA",codedWidth:i,codedHeight:r,timestamp:0});c.encode(b),b.close(),await c.flush(),u(!0)}catch{u(!1)}}):!0};/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class qe{constructor(){this._connectedTrack=null,this._closingPromise=null,this._closed=!1,this._timestampOffset=0}_ensureValidAdd(){if(!this._connectedTrack)throw new Error("Source is not connected to an output track.");if(this._connectedTrack.output.state==="canceled")throw new Error("Output has been canceled.");if(this._connectedTrack.output.state==="finalizing"||this._connectedTrack.output.state==="finalized")throw new Error("Output has been finalized.");if(this._connectedTrack.output.state==="pending")throw new Error("Output has not started.");if(this._closed)throw new Error("Source is closed.")}async _start(){}async _flushAndClose(e){}close(){if(this._closingPromise)return;const e=this._connectedTrack;if(!e)throw new Error("Cannot call close without connecting the source to an output track.");if(e.output.state==="pending")throw new Error("Cannot call close before output has been started.");this._closingPromise=(async()=>{await this._flushAndClose(!1),this._closed=!0,!(e.output.state==="finalizing"||e.output.state==="finalized")&&e.output._muxer.onTrackClose(e)})()}async _flushOrWaitForOngoingClose(e){return this._closingPromise??(this._closingPromise=(async()=>{await this._flushAndClose(e),this._closed=!0})())}}class Jt extends qe{constructor(e){if(super(),this._connectedTrack=null,!J.includes(e))throw new TypeError(`Invalid video codec '${e}'. Must be one of: ${J.join(", ")}.`);this._codec=e}}class ks extends Jt{constructor(e){super(e)}add(e,i){if(!(e instanceof pe))throw new TypeError("packet must be an EncodedPacket.");if(e.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be added.");if(i!==void 0&&(!i||typeof i!="object"))throw new TypeError("meta, when provided, must be an object.");return this._ensureValidAdd(),this._connectedTrack.output._muxer.addEncodedVideoPacket(this._connectedTrack,e,i)}}class ws extends qe{constructor(e){if(super(),this._connectedTrack=null,!de.includes(e))throw new TypeError(`Invalid audio codec '${e}'. Must be one of: ${de.join(", ")}.`);this._codec=e}}class ys extends qe{constructor(e){if(super(),this._connectedTrack=null,!se.includes(e))throw new TypeError(`Invalid subtitle codec '${e}'. Must be one of: ${se.join(", ")}.`);this._codec=e}}/*!
 * Copyright (c) 2026-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const bs=["video","audio","subtitle"],Fe=t=>{if(!t||typeof t!="object")throw new TypeError("metadata must be an object.");if(t.languageCode!==void 0&&!si(t.languageCode))throw new TypeError("metadata.languageCode, when provided, must be a three-letter, ISO 639-2/T language code.");if(t.name!==void 0&&typeof t.name!="string")throw new TypeError("metadata.name, when provided, must be a string.");if(t.disposition!==void 0&&ui(t.disposition),t.maximumPacketCount!==void 0&&(!Number.isInteger(t.maximumPacketCount)||t.maximumPacketCount<0))throw new TypeError("metadata.maximumPacketCount, when provided, must be a non-negative integer.")};class Ss{constructor(e){if(this.state="pending",this._tracks=[],this._startPromise=null,this._cancelPromise=null,this._finalizePromise=null,this._mutex=new Ct,this._metadataTags={},!e||typeof e!="object")throw new TypeError("options must be an object.");if(!(e.format instanceof je))throw new TypeError("options.format must be an OutputFormat.");if(!(e.target instanceof $e))throw new TypeError("options.target must be a Target.");if(e.target._output)throw new Error("Target is already used for another output.");e.target._output=this,this.format=e.format,this.target=e.target,this._writer=e.target._createWriter(),this._muxer=e.format._createMuxer(this)}addVideoTrack(e,i={}){if(!(e instanceof Jt))throw new TypeError("source must be a VideoSource.");if(Fe(i),i.rotation!==void 0&&![0,90,180,270].includes(i.rotation))throw new TypeError(`Invalid video rotation: ${i.rotation}. Has to be 0, 90, 180 or 270.`);if(!this.format.supportsVideoRotationMetadata&&i.rotation)throw new Error(`${this.format._name} does not support video rotation metadata.`);if(i.frameRate!==void 0&&(!Number.isFinite(i.frameRate)||i.frameRate<=0))throw new TypeError(`Invalid video frame rate: ${i.frameRate}. Must be a positive number.`);this._addTrack("video",e,i)}addAudioTrack(e,i={}){if(!(e instanceof ws))throw new TypeError("source must be an AudioSource.");Fe(i),this._addTrack("audio",e,i)}addSubtitleTrack(e,i={}){if(!(e instanceof ys))throw new TypeError("source must be a SubtitleSource.");Fe(i),this._addTrack("subtitle",e,i)}setMetadataTags(e){if(li(e),this.state!=="pending")throw new Error("Cannot set metadata tags after output has been started or canceled.");this._metadataTags=e}_addTrack(e,i,r){if(this.state!=="pending")throw new Error("Cannot add track after output has been started or canceled.");if(i._connectedTrack)throw new Error("Source is already used for a track.");const s=this.format.getSupportedTrackCounts(),n=this._tracks.reduce((u,c)=>u+(c.type===e?1:0),0),o=s[e].max;if(n===o)throw new Error(o===0?`${this.format._name} does not support ${e} tracks.`:`${this.format._name} does not support more than ${o} ${e} track${o===1?"":"s"}.`);const a=s.total.max;if(this._tracks.length===a)throw new Error(`${this.format._name} does not support more than ${a} tracks${a===1?"":"s"} in total.`);const l={id:this._tracks.length+1,output:this,type:e,source:i,metadata:r};if(l.type==="video"){const u=this.format.getSupportedVideoCodecs();if(u.length===0)throw new Error(`${this.format._name} does not support video tracks.`+this.format._codecUnsupportedHint(l.source._codec));if(!u.includes(l.source._codec))throw new Error(`Codec '${l.source._codec}' cannot be contained within ${this.format._name}. Supported video codecs are: ${u.map(c=>`'${c}'`).join(", ")}.`+this.format._codecUnsupportedHint(l.source._codec))}else if(l.type==="audio"){const u=this.format.getSupportedAudioCodecs();if(u.length===0)throw new Error(`${this.format._name} does not support audio tracks.`+this.format._codecUnsupportedHint(l.source._codec));if(!u.includes(l.source._codec))throw new Error(`Codec '${l.source._codec}' cannot be contained within ${this.format._name}. Supported audio codecs are: ${u.map(c=>`'${c}'`).join(", ")}.`+this.format._codecUnsupportedHint(l.source._codec))}else if(l.type==="subtitle"){const u=this.format.getSupportedSubtitleCodecs();if(u.length===0)throw new Error(`${this.format._name} does not support subtitle tracks.`+this.format._codecUnsupportedHint(l.source._codec));if(!u.includes(l.source._codec))throw new Error(`Codec '${l.source._codec}' cannot be contained within ${this.format._name}. Supported subtitle codecs are: ${u.map(c=>`'${c}'`).join(", ")}.`+this.format._codecUnsupportedHint(l.source._codec))}this._tracks.push(l),i._connectedTrack=l}async start(){const e=this.format.getSupportedTrackCounts();for(const r of bs){const s=this._tracks.reduce((o,a)=>o+(a.type===r?1:0),0),n=e[r].min;if(s<n)throw new Error(n===e[r].max?`${this.format._name} requires exactly ${n} ${r} track${n===1?"":"s"}.`:`${this.format._name} requires at least ${n} ${r} track${n===1?"":"s"}.`)}const i=e.total.min;if(this._tracks.length<i)throw new Error(i===e.total.max?`${this.format._name} requires exactly ${i} track${i===1?"":"s"}.`:`${this.format._name} requires at least ${i} track${i===1?"":"s"}.`);if(this.state==="canceled")throw new Error("Output has been canceled.");return this._startPromise?(console.warn("Output has already been started."),this._startPromise):this._startPromise=(async()=>{this.state="started",this._writer.start();const r=await this._mutex.acquire();await this._muxer.start();const s=this._tracks.map(n=>n.source._start());await Promise.all(s),r()})()}getMimeType(){return this._muxer.getMimeType()}async cancel(){if(this._cancelPromise)return console.warn("Output has already been canceled."),this._cancelPromise;if(this.state==="finalizing"||this.state==="finalized"){console.warn("Output has already been finalized.");return}return this._cancelPromise=(async()=>{this.state="canceled";const e=await this._mutex.acquire(),i=this._tracks.map(r=>r.source._flushOrWaitForOngoingClose(!0));await Promise.all(i),await this._writer.close(),e()})()}async finalize(){if(this.state==="pending")throw new Error("Cannot finalize before starting.");if(this.state==="canceled")throw new Error("Cannot finalize after canceling.");return this._finalizePromise?(console.warn("Output has already been finalized."),this._finalizePromise):this._finalizePromise=(async()=>{this.state="finalizing";const e=await this._mutex.acquire(),i=this._tracks.map(r=>r.source._flushOrWaitForOngoingClose(!1));await Promise.all(i),await this._muxer.finalize(),await this._writer.flush(),await this._writer.finalize(),this.state="finalized",e()})()}}export{as as B,ks as E,ps as M,Ss as O,Ts as S,gt as W,pe as a,Cs as c};
