
export const BLUE_NOISE = `
// Uniforms are auto-generated by Schema

// Golden Ratio (Conjugate)
const float PHI = 1.61803398875;

vec4 getBlueNoise4(vec2 screenCoord) {
    vec2 res = max(uBlueNoiseResolution, vec2(64.0));
    
    // 1. Static Spatial Lookup
    // Map screen pixels 1:1 to the texture. 
    // We do NOT add a temporal offset to UVs here. This prevents "streaking" artifacts
    // caused by dragging the noise pattern across the screen.
    vec2 uv = mod(screenCoord, res) / res;
    
    // 2. Fetch Base Blue Noise
    // This value is constant for a specific pixel across all frames.
    // It provides the high-quality spatial distribution (dithering).
    vec4 blue = textureLod(uBlueNoiseTexture, uv, 0.0);
    
    // 3. Temporal Animation (The Martin Roberts Method)
    // To ensure convergence over time (Monte Carlo integration), we need the value 
    // at this pixel to vary randomly frame-by-frame.
    // We add the Golden Ratio * FrameCount and wrap (fract).
    // This creates a Low-Discrepancy Sequence at every single pixel.
    
    float frameOffset = float(uFrameCount) * PHI;
    
    return vec4(
        fract(blue.r + frameOffset),
        fract(blue.g + frameOffset), 
        fract(blue.b + frameOffset),
        fract(blue.a + frameOffset)
    );
}

float getBlueNoise(vec2 screenCoord) {
    return getBlueNoise4(screenCoord).r;
}
`;
